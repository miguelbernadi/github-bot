# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module Addressable
end

module Addressable::IDNA
  ACE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  ACE_PREFIX = ::T.let(nil, ::T.untyped)
  COMPOSITION_TABLE = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  PUNYCODE_BASE = ::T.let(nil, ::T.untyped)
  PUNYCODE_DAMP = ::T.let(nil, ::T.untyped)
  PUNYCODE_DELIMITER = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_BIAS = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_N = ::T.let(nil, ::T.untyped)
  PUNYCODE_MAXINT = ::T.let(nil, ::T.untyped)
  PUNYCODE_PRINT_ASCII = ::T.let(nil, ::T.untyped)
  PUNYCODE_SKEW = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMAX = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMIN = ::T.let(nil, ::T.untyped)
  UNICODE_DATA = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_CANONICAL = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMBINING_CLASS = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMPATIBILITY = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_EXCLUSION = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_LOWERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_TITLECASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_UPPERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  UNICODE_TABLE = ::T.let(nil, ::T.untyped)
  UTF8_REGEX = ::T.let(nil, ::T.untyped)
  UTF8_REGEX_MULTIBYTE = ::T.let(nil, ::T.untyped)
end

class Addressable::IDNA::PunycodeBadInput
end

class Addressable::IDNA::PunycodeBadInput
end

class Addressable::IDNA::PunycodeBigOutput
end

class Addressable::IDNA::PunycodeBigOutput
end

class Addressable::IDNA::PunycodeOverflow
end

class Addressable::IDNA::PunycodeOverflow
end

module Addressable::IDNA
  def self.to_ascii(input); end

  def self.to_unicode(input); end

  def self.unicode_normalize_kc(input); end
end

class Addressable::Template
  def ==(template); end

  def eql?(template); end

  def expand(mapping, processor=T.unsafe(nil), normalize_values=T.unsafe(nil)); end

  def extract(uri, processor=T.unsafe(nil)); end

  def generate(params=T.unsafe(nil), recall=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(pattern); end

  def keys(); end

  def match(uri, processor=T.unsafe(nil)); end

  def named_captures(); end

  def names(); end

  def partial_expand(mapping, processor=T.unsafe(nil), normalize_values=T.unsafe(nil)); end

  def pattern(); end

  def source(); end

  def to_regexp(); end

  def variable_defaults(); end

  def variables(); end
  EXPRESSION = ::T.let(nil, ::T.untyped)
  JOINERS = ::T.let(nil, ::T.untyped)
  LEADERS = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  VARIABLE_LIST = ::T.let(nil, ::T.untyped)
  VARNAME = ::T.let(nil, ::T.untyped)
  VARSPEC = ::T.let(nil, ::T.untyped)
end

class Addressable::Template::InvalidTemplateOperatorError
end

class Addressable::Template::InvalidTemplateOperatorError
end

class Addressable::Template::InvalidTemplateValueError
end

class Addressable::Template::InvalidTemplateValueError
end

class Addressable::Template::MatchData
  def [](key, len=T.unsafe(nil)); end

  def captures(); end

  def initialize(uri, template, mapping); end

  def keys(); end

  def mapping(); end

  def names(); end

  def post_match(); end

  def pre_match(); end

  def string(); end

  def template(); end

  def to_a(); end

  def uri(); end

  def values(); end

  def values_at(*indexes); end

  def variables(); end
end

class Addressable::Template::MatchData
end

class Addressable::Template::TemplateOperatorAbortedError
end

class Addressable::Template::TemplateOperatorAbortedError
end

class Addressable::Template
end

class Addressable::URI
  def +(uri); end

  def ==(uri); end

  def ===(uri); end

  def absolute?(); end

  def authority(); end

  def authority=(new_authority); end

  def basename(); end

  def default_port(); end

  def defer_validation(); end

  def display_uri(); end

  def domain(); end

  def empty?(); end

  def eql?(uri); end

  def extname(); end

  def fragment(); end

  def fragment=(new_fragment); end

  def host(); end

  def host=(new_host); end

  def hostname(); end

  def hostname=(new_hostname); end

  def inferred_port(); end

  def initialize(options=T.unsafe(nil)); end

  def ip_based?(); end

  def join(uri); end

  def join!(uri); end

  def merge(hash); end

  def merge!(uri); end

  def normalize(); end

  def normalize!(); end

  def normalized_authority(); end

  def normalized_fragment(); end

  def normalized_host(); end

  def normalized_password(); end

  def normalized_path(); end

  def normalized_port(); end

  def normalized_query(*flags); end

  def normalized_scheme(); end

  def normalized_site(); end

  def normalized_user(); end

  def normalized_userinfo(); end

  def omit(*components); end

  def omit!(*components); end

  def origin(); end

  def origin=(new_origin); end

  def password(); end

  def password=(new_password); end

  def path(); end

  def path=(new_path); end

  def port(); end

  def port=(new_port); end

  def query(); end

  def query=(new_query); end

  def query_values(return_type=T.unsafe(nil)); end

  def query_values=(new_query_values); end

  def relative?(); end

  def remove_composite_values(); end

  def replace_self(uri); end

  def request_uri(); end

  def request_uri=(new_request_uri); end

  def route_from(uri); end

  def route_to(uri); end

  def scheme(); end

  def scheme=(new_scheme); end

  def site(); end

  def site=(new_site); end

  def split_path(path); end

  def tld(); end

  def tld=(new_tld); end

  def to_hash(); end

  def to_str(); end

  def user(); end

  def user=(new_user); end

  def userinfo(); end

  def userinfo=(new_userinfo); end

  def validate(); end
  EMPTY_STR = ::T.let(nil, ::T.untyped)
  NORMPATH = ::T.let(nil, ::T.untyped)
  PARENT = ::T.let(nil, ::T.untyped)
  PORT_MAPPING = ::T.let(nil, ::T.untyped)
  RULE_2A = ::T.let(nil, ::T.untyped)
  RULE_2B_2C = ::T.let(nil, ::T.untyped)
  RULE_2D = ::T.let(nil, ::T.untyped)
  RULE_PREFIXED_PARENT = ::T.let(nil, ::T.untyped)
  SELF_REF = ::T.let(nil, ::T.untyped)
  SEQUENCE_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SEQUENCE_UPCASED_PERCENT_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  URIREGEX = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
  ALPHA = ::T.let(nil, ::T.untyped)
  AUTHORITY = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  GEN_DELIMS = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PCHAR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
end

class Addressable::URI::InvalidURIError
end

class Addressable::URI::InvalidURIError
end

class Addressable::URI
  def self.convert_path(path); end

  def self.encode(uri, return_type=T.unsafe(nil)); end

  def self.encode_component(component, character_class=T.unsafe(nil), upcase_encoded=T.unsafe(nil)); end

  def self.escape(uri, return_type=T.unsafe(nil)); end

  def self.form_encode(form_values, sort=T.unsafe(nil)); end

  def self.form_unencode(encoded_value); end

  def self.heuristic_parse(uri, hints=T.unsafe(nil)); end

  def self.ip_based_schemes(); end

  def self.join(*uris); end

  def self.normalize_component(component, character_class=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.normalize_path(path); end

  def self.normalized_encode(uri, return_type=T.unsafe(nil)); end

  def self.parse(uri); end

  def self.port_mapping(); end

  def self.unencode(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unencode_component(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unescape(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unescape_component(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end
end

module Addressable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module Addressable::VERSION
end

module Addressable
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def bsearch(); end

  def bsearch_index(); end

  def collect!(); end

  def dig(*_); end

  def flatten!(*_); end

  def pack(*_); end

  def replace(_); end

  def shelljoin(); end

  def to_csv(**options); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

BasicObject::BasicObject = BasicObject

class BasicSocket
  def read_nonblock(len, str=T.unsafe(nil), exception: T.unsafe(nil)); end
end

class BigDecimal
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.ver(); end
end

class Binding
  def clone(); end

  def irb(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

class Bundler::GemHelper
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
  def initialize(gem, options=T.unsafe(nil)); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Class
  def json_creatable?(); end
end

class Complex
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

class CompositeReadIO
  def initialize(*ios); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class CompositeReadIO
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Delegator
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
end

class Delegator
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

class Dir
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

  def result_with_hash(hash); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding
  def self._load(_); end

  def self.locale_charmap(); end
end

module Enumerable
  def chunk(); end

  def chunk_while(); end

  def each_entry(*_); end

  def grep_v(_); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(*_); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end

  def zip(*_); end
end

class Enumerator
  def each_with_index(); end
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

Errno::EAUTH = Errno::NOERROR

Errno::EBADRPC = Errno::NOERROR

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::EDEADLK

Errno::EDOOFUS = Errno::NOERROR

Errno::EFTYPE = Errno::NOERROR

Errno::EIPSEC = Errno::NOERROR

Errno::ENEEDAUTH = Errno::NOERROR

Errno::ENOATTR = Errno::NOERROR

Errno::ENOTCAPABLE = Errno::NOERROR

Errno::ENOTSUP = Errno::EOPNOTSUPP

Errno::EPROCLIM = Errno::NOERROR

Errno::EPROCUNAVAIL = Errno::NOERROR

Errno::EPROGMISMATCH = Errno::NOERROR

Errno::EPROGUNAVAIL = Errno::NOERROR

Errno::ERPCMISMATCH = Errno::NOERROR

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def dir(); end

  def dir=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid(); end

  def gid=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end

  def shell(); end

  def shell=(_); end

  def uid(); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

module Etc
  def self.confstr(_); end

  def self.endgrent(); end

  def self.endpwent(); end

  def self.getgrent(); end

  def self.getgrgid(*_); end

  def self.getgrnam(_); end

  def self.getlogin(); end

  def self.getpwent(); end

  def self.getpwnam(_); end

  def self.getpwuid(*_); end

  def self.group(); end

  def self.nprocessors(); end

  def self.passwd(); end

  def self.setgrent(); end

  def self.setpwent(); end

  def self.sysconf(_); end

  def self.sysconfdir(); end

  def self.systmpdir(); end

  def self.uname(); end
end

class Exception
  def full_message(*_); end
end

class Exception
  def self.exception(*_); end

  def self.to_tty?(); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

module Faraday
  METHODS_WITH_BODY = ::T.let(nil, ::T.untyped)
  METHODS_WITH_QUERY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter
  def call(env); end

  def initialize(_app=T.unsafe(nil), opts=T.unsafe(nil), &block); end
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::EMHttp
  include ::Faraday::Adapter::EMHttp::Options
  def create_request(env); end

  def error_message(client); end

  def parallel?(env); end

  def perform_request(env); end

  def perform_single_request(env); end

  def raise_error(msg); end

  def timeout_message?(msg); end
end

class Faraday::Adapter::EMHttp::Manager
  def add(&block); end

  def check_finished(); end

  def perform_request(); end

  def reset(); end

  def run(); end

  def running?(); end
end

class Faraday::Adapter::EMHttp::Manager
end

module Faraday::Adapter::EMHttp::Options
  def configure_compression(options, env); end

  def configure_proxy(options, env); end

  def configure_socket(options, env); end

  def configure_ssl(options, env); end

  def configure_timeout(options, env); end

  def connection_config(env); end

  def read_body(env); end

  def request_config(env); end

  def request_options(env); end
end

module Faraday::Adapter::EMHttp::Options
end

class Faraday::Adapter::EMHttp
  def self.setup_parallel_manager(_options=T.unsafe(nil)); end
end

class Faraday::Adapter::EMSynchrony
  include ::Faraday::Adapter::EMHttp::Options
  def create_request(env); end
end

class Faraday::Adapter::EMSynchrony::ParallelManager
  def add(request, method, *args, &block); end

  def run(); end
end

class Faraday::Adapter::EMSynchrony::ParallelManager
end

class Faraday::Adapter::EMSynchrony
  def self.setup_parallel_manager(_options=T.unsafe(nil)); end
end

class Faraday::Adapter::Excon
  def create_connection(env, opts); end

  def read_body(env); end
  OPTS_KEYS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Excon
end

class Faraday::Adapter::HTTPClient
  def client(); end

  def configure_client(); end

  def configure_open_timeout(req); end

  def configure_proxy(proxy); end

  def configure_socket(bind); end

  def configure_ssl(ssl); end

  def configure_timeout(req); end

  def configure_timeouts(req); end

  def ssl_cert_store(ssl); end

  def ssl_verify_mode(ssl); end
end

class Faraday::Adapter::HTTPClient
end

class Faraday::Adapter::NetHttp
  def initialize(app=T.unsafe(nil), opts=T.unsafe(nil), &block); end
  NET_HTTP_EXCEPTIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::NetHttp
end

class Faraday::Adapter::NetHttpPersistent
  SSL_CONFIGURATIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::NetHttpPersistent
end

module Faraday::Adapter::Parallelism
  def inherited(subclass); end

  def supports_parallel=(supports_parallel); end

  def supports_parallel?(); end
end

module Faraday::Adapter::Parallelism
end

class Faraday::Adapter::Patron
  def configure_ssl(session, ssl); end
  CURL_TIMEOUT_MESSAGES = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Patron
end

class Faraday::Adapter::Rack
  def initialize(faraday_app, rack_app); end
  SPECIAL_HEADERS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Rack
end

class Faraday::Adapter::Test
  def configure(); end

  def initialize(app, stubs=T.unsafe(nil), &block); end

  def stubs(); end

  def stubs=(stubs); end
end

class Faraday::Adapter::Test::Stub
  def headers_match?(request_headers); end

  def initialize(host, full, headers, body, block); end

  def matches?(request_host, request_uri, request_headers, request_body); end

  def params_match?(request_params); end

  def path_match?(request_path, meta); end
end

class Faraday::Adapter::Test::Stub
end

class Faraday::Adapter::Test::Stubs
  def delete(path, headers=T.unsafe(nil), &block); end

  def empty?(); end

  def get(path, headers=T.unsafe(nil), &block); end

  def head(path, headers=T.unsafe(nil), &block); end

  def match(request_method, host, path, headers, body); end

  def matches?(stack, host, path, headers, body); end

  def new_stub(request_method, path, headers=T.unsafe(nil), body=T.unsafe(nil), &block); end

  def options(path, headers=T.unsafe(nil), &block); end

  def patch(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def post(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def put(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def verify_stubbed_calls(); end
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs
end

class Faraday::Adapter::Test
end

class Faraday::Adapter::Typhoeus
  def call(); end
end

class Faraday::Adapter::Typhoeus
end

class Faraday::Adapter
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::DependencyLoader
  extend ::Faraday::Adapter::Parallelism
  extend ::Faraday::AutoloadHelper
end

class Faraday::AdapterRegistry
  def get(name); end

  def set(klass, name=T.unsafe(nil)); end
end

class Faraday::AdapterRegistry
end

module Faraday::AutoloadHelper
  def all_loaded_constants(); end

  def autoload_all(prefix, options); end

  def load_autoloaded_constants(); end
end

module Faraday::AutoloadHelper
end

class Faraday::BadRequestError
end

class Faraday::BadRequestError
end

class Faraday::ClientError
end

class Faraday::ClientError
end

class Faraday::CompositeReadIO
  def close(); end

  def ensure_open_and_readable(); end

  def initialize(*parts); end

  def length(); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class Faraday::CompositeReadIO
end

class Faraday::ConflictError
end

class Faraday::ConflictError
end

class Faraday::Connection
  def adapter(*args, &block); end

  def app(*args, &block); end

  def authorization(type, token); end

  def basic_auth(login, pass); end

  def build(*args, &block); end

  def build_exclusive_url(url=T.unsafe(nil), params=T.unsafe(nil), params_encoder=T.unsafe(nil)); end

  def build_request(method); end

  def build_url(url=T.unsafe(nil), extra_params=T.unsafe(nil)); end

  def builder(); end

  def connect(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def default_parallel_manager(); end

  def default_parallel_manager=(default_parallel_manager); end

  def delete(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def find_default_proxy(); end

  def get(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def head(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def headers(); end

  def headers=(hash); end

  def host(*args, &block); end

  def host=(*args, &block); end

  def in_parallel(manager=T.unsafe(nil)); end

  def in_parallel?(); end

  def initialize(url=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize_proxy(url, options); end

  def options(*args); end

  def parallel_manager(); end

  def params(); end

  def params=(hash); end

  def patch(url=T.unsafe(nil), body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def path_prefix(*args, &block); end

  def path_prefix=(value); end

  def port(*args, &block); end

  def port=(*args, &block); end

  def post(url=T.unsafe(nil), body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def proxy(); end

  def proxy=(new_value); end

  def proxy_for_request(url); end

  def proxy_from_env(url); end

  def put(url=T.unsafe(nil), body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def request(*args, &block); end

  def response(*args, &block); end

  def run_request(method, url, body, headers); end

  def scheme(*args, &block); end

  def scheme=(*args, &block); end

  def set_authorization_header(header_type, *args); end

  def ssl(); end

  def support_parallel?(adapter); end

  def token_auth(token, options=T.unsafe(nil)); end

  def trace(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def url_prefix(); end

  def url_prefix=(url, encoder=T.unsafe(nil)); end

  def use(*args, &block); end

  def with_uri_credentials(uri); end
  METHODS = ::T.let(nil, ::T.untyped)
end

class Faraday::Connection
  extend ::Forwardable
end

class Faraday::ConnectionFailed
end

class Faraday::ConnectionFailed
end

class Faraday::ConnectionOptions
  def new_builder(block); end
end

class Faraday::ConnectionOptions
end

module Faraday::DecodeMethods
  def add_to_context(is_array, context, value, subkey); end

  def decode(query); end

  def decode_pair(key, value, context); end

  def dehash(hash, depth); end

  def match_context(context, subkey); end

  def new_context(subkey, is_array, context); end

  def prepare_context(context, subkey, is_array, last_subkey); end
  SUBKEYS_REGEX = ::T.let(nil, ::T.untyped)
end

module Faraday::DecodeMethods
end

module Faraday::DependencyLoader
  def dependency(lib=T.unsafe(nil)); end

  def inherited(subclass); end

  def load_error(); end

  def loaded?(); end

  def new(*_); end
end

module Faraday::DependencyLoader
end

module Faraday::DeprecatedClass
end

module Faraday::DeprecatedClass
  def self.proxy_class(old_klass, new_klass); end
end

module Faraday::EncodeMethods
  def encode(params); end

  def encode_array(parent, value); end

  def encode_hash(parent, value); end

  def encode_pair(parent, value); end
end

module Faraday::EncodeMethods
end

class Faraday::Env
  def []=(key, value); end

  def body(); end

  def body=(value); end

  def clear_body(); end

  def current_body(); end

  def custom_members(); end

  def in_member_set?(key); end

  def needs_body?(); end

  def parallel?(); end

  def params_encoder(*args, &block); end

  def parse_body?(); end

  def success?(); end
  ContentLength = ::T.let(nil, ::T.untyped)
  MethodsWithBodies = ::T.let(nil, ::T.untyped)
  StatusesWithoutBody = ::T.let(nil, ::T.untyped)
  SuccessfulStatuses = ::T.let(nil, ::T.untyped)
end

class Faraday::Env
  extend ::Forwardable
  def self.member_set(); end
end

class Faraday::Error
  def initialize(exc, response=T.unsafe(nil)); end

  def response(); end

  def wrapped_exception(); end
end

class Faraday::Error::ClientError
  def initialize(*args, &block); end

  def warn(); end
end

class Faraday::Error::ClientError
end

class Faraday::Error::ConnectionFailed
  def initialize(*args, &block); end

  def warn(); end
end

class Faraday::Error::ConnectionFailed
end

class Faraday::Error::ParsingError
  def initialize(*args, &block); end

  def warn(); end
end

class Faraday::Error::ParsingError
end

class Faraday::Error::ResourceNotFound
  def initialize(*args, &block); end

  def warn(); end
end

class Faraday::Error::ResourceNotFound
end

class Faraday::Error::RetriableResponse
  def initialize(*args, &block); end

  def warn(); end
end

class Faraday::Error::RetriableResponse
end

class Faraday::Error::SSLError
  def initialize(*args, &block); end

  def warn(); end
end

class Faraday::Error::SSLError
end

class Faraday::Error::TimeoutError
  def initialize(*args, &block); end

  def warn(); end
end

class Faraday::Error::TimeoutError
end

class Faraday::Error
end

Faraday::FilePart = UploadIO

module Faraday::FlatParamsEncoder
end

module Faraday::FlatParamsEncoder
  def self.decode(query); end

  def self.encode(params); end

  def self.escape(*args, &block); end

  def self.unescape(*args, &block); end
end

class Faraday::ForbiddenError
end

class Faraday::ForbiddenError
end

class Faraday::Middleware
  def initialize(app=T.unsafe(nil)); end
end

class Faraday::Middleware
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::DependencyLoader
end

module Faraday::MiddlewareRegistry
  def fetch_middleware(key); end

  def load_middleware(key); end

  def lookup_middleware(key); end

  def middleware_mutex(&block); end

  def register_middleware(autoload_path=T.unsafe(nil), mapping=T.unsafe(nil)); end

  def unregister_middleware(key); end
end

module Faraday::MiddlewareRegistry
end

module Faraday::NestedParamsEncoder
end

module Faraday::NestedParamsEncoder
  extend ::Faraday::EncodeMethods
  extend ::Faraday::DecodeMethods
  def self.escape(*args, &block); end

  def self.unescape(*args, &block); end
end

class Faraday::Options
  def [](key); end

  def clear(); end

  def deep_dup(); end

  def delete(key); end

  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, *args); end

  def has_key?(key); end

  def has_value?(value); end

  def key?(key); end

  def keys(); end

  def merge(other); end

  def merge!(other); end

  def symbolized_key_set(); end

  def to_hash(); end

  def update(obj); end

  def value?(value); end

  def values_at(*keys); end
end

class Faraday::Options
  def self.attribute_options(); end

  def self.fetch_error_class(); end

  def self.from(value); end

  def self.inherited(subclass); end

  def self.memoized(key, &block); end

  def self.memoized_attributes(); end

  def self.options(mapping); end

  def self.options_for(key); end
end

class Faraday::ParamPart
  def content_id(); end

  def content_type(); end

  def headers(); end

  def initialize(value, content_type, content_id=T.unsafe(nil)); end

  def to_part(boundary, key); end

  def value(); end
end

class Faraday::ParamPart
end

class Faraday::ParsingError
end

class Faraday::ParsingError
end

Faraday::Parts = Parts

class Faraday::ProxyAuthError
end

class Faraday::ProxyAuthError
end

class Faraday::ProxyOptions
  def host(*args, &block); end

  def host=(*args, &block); end

  def path(*args, &block); end

  def path=(*args, &block); end

  def port(*args, &block); end

  def port=(*args, &block); end

  def scheme(*args, &block); end

  def scheme=(*args, &block); end
end

class Faraday::ProxyOptions
  extend ::Forwardable
end

class Faraday::RackBuilder
  def ==(other); end

  def [](idx); end

  def adapter(klass=T.unsafe(nil), *args, &block); end

  def app(); end

  def build(options=T.unsafe(nil)); end

  def build_env(connection, request); end

  def build_response(connection, request); end

  def delete(handler); end

  def handlers(); end

  def handlers=(handlers); end

  def initialize(handlers=T.unsafe(nil), adapter=T.unsafe(nil), &block); end

  def insert(index, *args, &block); end

  def insert_after(index, *args, &block); end

  def insert_before(index, *args, &block); end

  def lock!(); end

  def locked?(); end

  def request(key, *args, &block); end

  def response(key, *args, &block); end

  def swap(index, *args, &block); end

  def to_app(); end

  def use(klass, *args, &block); end
  LOCK_ERR = ::T.let(nil, ::T.untyped)
  NO_ARGUMENT = ::T.let(nil, ::T.untyped)
end

class Faraday::RackBuilder::Handler
  def ==(other); end

  def build(app=T.unsafe(nil)); end

  def initialize(klass, *args, &block); end

  def klass(); end

  def name(); end
  REGISTRY = ::T.let(nil, ::T.untyped)
end

class Faraday::RackBuilder::Handler
end

class Faraday::RackBuilder::StackLocked
end

class Faraday::RackBuilder::StackLocked
end

class Faraday::RackBuilder
end

class Faraday::Request
  def [](key); end

  def []=(key, value); end

  def headers=(hash); end

  def marshal_dump(); end

  def marshal_load(serialised); end

  def params=(hash); end

  def to_env(connection); end

  def url(path, params=T.unsafe(nil)); end
end

class Faraday::Request::Authorization
  def call(env); end

  def initialize(app, type, token); end
  KEY = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Authorization
  def self.build_hash(type, hash); end

  def self.header(type, token); end
end

class Faraday::Request::BasicAuthentication
end

class Faraday::Request::BasicAuthentication
  def self.header(login, pass); end
end

class Faraday::Request::Instrumentation
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation
end

class Faraday::Request::Multipart
  def create_multipart(env, params); end

  def has_multipart?(obj); end

  def part(boundary, key, value); end

  def process_params(params, prefix=T.unsafe(nil), pieces=T.unsafe(nil), &block); end

  def unique_boundary(); end
  DEFAULT_BOUNDARY_PREFIX = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Multipart
end

class Faraday::Request::Retry
  def build_exception_matcher(exceptions); end

  def calculate_sleep_amount(retries, env); end

  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
  DEFAULT_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Retry::Options
  DEFAULT_CHECK = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Retry::Options
end

class Faraday::Request::Retry
end

class Faraday::Request::TokenAuthentication
  def initialize(app, token, options=T.unsafe(nil)); end
end

class Faraday::Request::TokenAuthentication
  def self.header(token, options=T.unsafe(nil)); end
end

class Faraday::Request::UrlEncoded
  def call(env); end

  def match_content_type(env); end

  def process_request?(env); end

  def request_type(env); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::UrlEncoded
  def self.mime_type(); end

  def self.mime_type=(mime_type); end
end

class Faraday::Request
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::AutoloadHelper
  def self.create(request_method); end
end

class Faraday::RequestOptions
  def []=(key, value); end

  def stream_response?(); end
end

class Faraday::RequestOptions
end

class Faraday::ResourceNotFound
end

class Faraday::ResourceNotFound
end

class Faraday::Response
  def [](*args, &block); end

  def apply_request(request_env); end

  def body(); end

  def env(); end

  def finish(env); end

  def finished?(); end

  def headers(); end

  def initialize(env=T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(env); end

  def on_complete(&block); end

  def reason_phrase(); end

  def status(); end

  def success?(); end

  def to_hash(); end
end

class Faraday::Response::Logger
  def initialize(app, logger=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Faraday::Response::Logger
end

class Faraday::Response::Middleware
  def call(env); end

  def on_complete(env); end
end

class Faraday::Response::Middleware
end

class Faraday::Response::RaiseError
  def response_values(env); end
  ClientErrorStatuses = ::T.let(nil, ::T.untyped)
  ServerErrorStatuses = ::T.let(nil, ::T.untyped)
end

class Faraday::Response::RaiseError
end

class Faraday::Response
  extend ::Forwardable
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::AutoloadHelper
end

class Faraday::RetriableResponse
end

class Faraday::RetriableResponse
end

class Faraday::SSLError
end

class Faraday::SSLError
end

class Faraday::SSLOptions
  def disable?(); end

  def verify?(); end
end

class Faraday::SSLOptions
end

class Faraday::ServerError
end

class Faraday::ServerError
end

class Faraday::TimeoutError
  def initialize(exc=T.unsafe(nil), response=T.unsafe(nil)); end
end

class Faraday::TimeoutError
end

Faraday::Timer = Timeout

class Faraday::UnauthorizedError
end

class Faraday::UnauthorizedError
end

class Faraday::UnprocessableEntityError
end

class Faraday::UnprocessableEntityError
end

Faraday::UploadIO = UploadIO

module Faraday::Utils
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
end

class Faraday::Utils::Headers
  def [](key); end

  def []=(key, val); end

  def delete(key); end

  def fetch(key, *args, &block); end

  def has_key?(key); end

  def include?(key); end

  def initialize(hash=T.unsafe(nil)); end

  def initialize_names(); end

  def key?(key); end

  def member?(key); end

  def merge(other); end

  def merge!(other); end

  def names(); end

  def parse(header_string); end

  def replace(other); end

  def update(other); end
  KeyMap = ::T.let(nil, ::T.untyped)
end

class Faraday::Utils::Headers
  def self.from(value); end
end

class Faraday::Utils::ParamsHash
  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def has_key?(key); end

  def include?(key); end

  def key?(key); end

  def member?(key); end

  def merge(params); end

  def merge!(params); end

  def merge_query(query, encoder=T.unsafe(nil)); end

  def replace(other); end

  def to_query(encoder=T.unsafe(nil)); end

  def update(params); end
end

class Faraday::Utils::ParamsHash
end

module Faraday::Utils
  def self.URI(url); end

  def self.build_nested_query(params); end

  def self.build_query(params); end

  def self.deep_merge(source, hash); end

  def self.deep_merge!(target, hash); end

  def self.default_params_encoder(); end

  def self.default_params_encoder=(default_params_encoder); end

  def self.default_uri_parser(); end

  def self.default_uri_parser=(parser); end

  def self.escape(str); end

  def self.normalize_path(url); end

  def self.parse_nested_query(query); end

  def self.parse_query(query); end

  def self.sort_query_params(query); end

  def self.unescape(str); end
end

module Faraday
  def self.default_adapter(); end

  def self.default_adapter=(adapter); end

  def self.default_connection(); end

  def self.default_connection=(default_connection); end

  def self.default_connection_options(); end

  def self.default_connection_options=(options); end

  def self.ignore_env_proxy(); end

  def self.ignore_env_proxy=(ignore_env_proxy); end

  def self.lib_path(); end

  def self.lib_path=(lib_path); end

  def self.new(url=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.require_lib(*libs); end

  def self.require_libs(*libs); end

  def self.respond_to_missing?(symbol, include_private=T.unsafe(nil)); end

  def self.root_path(); end

  def self.root_path=(root_path); end
end

class Fiber
  def resume(*_); end
end

class Fiber
  def self.yield(*_); end
end

class File
  Separator = ::T.let(nil, ::T.untyped)
end

class File::Stat
  def size?(); end
end

class File
  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

class FrozenError
end

class FrozenError
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end
end

class GHAapp
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Specification
  extend ::Enumerable
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def compact(); end

  def compact!(); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def dig(*_); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def merge!(_); end

  def replace(_); end

  def slice(*_); end

  def to_h(); end

  def to_proc(); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values(); end

  def transform_values!(); end

  def update(_); end
end

class Hash
  def self.try_convert(_); end
end

class IO
  def external_encoding(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def pathconf(_); end

  def pread(*_); end

  def pwrite(_, _1); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.foreach(*_); end

  def self.pipe(*_); end
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def nobits?(_); end

  def pow(*_); end

  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  def self.sqrt(_); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JWT
  include ::JWT::DefaultOptions
end

module JWT::Algos
end

module JWT::Algos::Ecdsa
  NAMED_CURVES = ::T.let(nil, ::T.untyped)
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Ecdsa
  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Eddsa
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Eddsa
  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Hmac
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Hmac
  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Ps
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Ps
  def self.require_openssl!(); end

  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Rsa
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Rsa
  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Unsupported
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Unsupported
  def self.sign(*_); end

  def self.verify(*_); end
end

module JWT::Algos
end

class JWT::Base64
end

class JWT::Base64
  def self.url_decode(str); end

  def self.url_encode(str); end
end

class JWT::ClaimsValidator
  def initialize(payload); end

  def validate!(); end
  INTEGER_CLAIMS = ::T.let(nil, ::T.untyped)
end

class JWT::ClaimsValidator
end

class JWT::Decode
  def decode_segments(); end

  def initialize(jwt, key, verify, options, &keyfinder); end
end

class JWT::Decode
end

class JWT::DecodeError
end

class JWT::DecodeError
end

module JWT::DefaultOptions
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module JWT::DefaultOptions
end

class JWT::Encode
  def initialize(options); end

  def segments(); end
  ALG_KEY = ::T.let(nil, ::T.untyped)
  ALG_NONE = ::T.let(nil, ::T.untyped)
end

class JWT::Encode
end

class JWT::EncodeError
end

class JWT::EncodeError
end

class JWT::ExpiredSignature
end

class JWT::ExpiredSignature
end

class JWT::ImmatureSignature
end

class JWT::ImmatureSignature
end

class JWT::IncorrectAlgorithm
end

class JWT::IncorrectAlgorithm
end

class JWT::InvalidAudError
end

class JWT::InvalidAudError
end

class JWT::InvalidIatError
end

class JWT::InvalidIatError
end

class JWT::InvalidIssuerError
end

class JWT::InvalidIssuerError
end

class JWT::InvalidJtiError
end

class JWT::InvalidJtiError
end

class JWT::InvalidPayload
end

class JWT::InvalidPayload
end

class JWT::InvalidSubError
end

class JWT::InvalidSubError
end

class JWT::JSON
end

class JWT::JSON
  def self.generate(data); end

  def self.parse(data); end
end

module JWT::JWK
  MAPPINGS = ::T.let(nil, ::T.untyped)
end

class JWT::JWK::KeyFinder
  def initialize(options); end

  def key_for(kid); end
end

class JWT::JWK::KeyFinder
end

class JWT::JWK::RSA
  def export(); end

  def initialize(keypair); end

  def keypair(); end

  def kid(); end

  def private?(*args, &block); end

  def public_key(*args, &block); end
  BINARY = ::T.let(nil, ::T.untyped)
  KTY = ::T.let(nil, ::T.untyped)
end

class JWT::JWK::RSA
  extend ::Forwardable
  def self.import(jwk_data); end
end

module JWT::JWK
  def self.create_from(keypair); end

  def self.import(jwk_data); end

  def self.new(keypair); end
end

class JWT::JWKError
end

class JWT::JWKError
end

class JWT::RequiredDependencyError
end

class JWT::RequiredDependencyError
end

module JWT::SecurityUtils
end

module JWT::SecurityUtils
  def self.asn1_to_raw(signature, public_key); end

  def self.raw_to_asn1(signature, private_key); end

  def self.rbnacl_fixup(algorithm, key); end

  def self.secure_compare(left, right); end

  def self.verify_ps(algorithm, public_key, signing_input, signature); end

  def self.verify_rsa(algorithm, public_key, signing_input, signature); end
end

module JWT::Signature
  def sign(algorithm, msg, key); end

  def verify(algorithm, key, signing_input, signature); end
  ALGOS = ::T.let(nil, ::T.untyped)
end

class JWT::Signature::ToSign
  def algorithm(); end

  def algorithm=(_); end

  def key(); end

  def key=(_); end

  def msg(); end

  def msg=(_); end
end

class JWT::Signature::ToSign
  def self.[](*_); end

  def self.members(); end
end

class JWT::Signature::ToVerify
  def algorithm(); end

  def algorithm=(_); end

  def public_key(); end

  def public_key=(_); end

  def signature(); end

  def signature=(_); end

  def signing_input(); end

  def signing_input=(_); end
end

class JWT::Signature::ToVerify
  def self.[](*_); end

  def self.members(); end
end

module JWT::Signature
  extend ::JWT::Signature
end

class JWT::VerificationError
end

class JWT::VerificationError
end

class JWT::Verify
  def initialize(payload, options); end

  def verify_aud(); end

  def verify_expiration(); end

  def verify_iat(); end

  def verify_iss(); end

  def verify_jti(); end

  def verify_not_before(); end

  def verify_sub(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class JWT::Verify
  def self.verify_aud(payload, options); end

  def self.verify_claims(payload, options); end

  def self.verify_expiration(payload, options); end

  def self.verify_iat(payload, options); end

  def self.verify_iss(payload, options); end

  def self.verify_jti(payload, options); end

  def self.verify_not_before(payload, options); end

  def self.verify_sub(payload, options); end
end

module JWT
  def self.decode(jwt, key=T.unsafe(nil), verify=T.unsafe(nil), options=T.unsafe(nil), &keyfinder); end

  def self.encode(payload, key, algorithm=T.unsafe(nil), header_fields=T.unsafe(nil)); end
end

module Kernel
  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def respond_to?(*_); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  def key(); end

  def receiver(); end
end

class LoadError
  def path(); end
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class Logger
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Marshal
  def self.restore(*_); end
end

Methods = T::Private::Methods

class Module
  def deprecate_constant(*_); end

  def undef_method(*_); end
end

class Module
  def self.used_modules(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
  EXCEPTION_IMMEDIATE = ::T.let(nil, ::T.untyped)
  EXCEPTION_NEVER = ::T.let(nil, ::T.untyped)
end

class MonitorMixin::ConditionVariable
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

module MonitorMixin
  def self.extend_object(obj); end
end

module Mustermann
  DEFAULT_TYPE = ::T.let(nil, ::T.untyped)
end

module Mustermann::AST
end

class Mustermann::AST::Boundaries
  def set_boundaries(node, start, stop); end
end

class Mustermann::AST::Boundaries::NodeTranslator
end

class Mustermann::AST::Boundaries::NodeTranslator
  def self.translator(); end
end

class Mustermann::AST::Boundaries
  def self.set_boundaries(ast, string: T.unsafe(nil), start: T.unsafe(nil), stop: T.unsafe(nil)); end
end

class Mustermann::AST::Expander
  def add(ast); end

  def add_to(list, result); end

  def error_for(values); end

  def escape(string, *args); end

  def expand(values); end

  def expandable?(values); end

  def expandable_keys(keys); end

  def for_capture(node, **options); end

  def keys(); end

  def mappings(); end

  def pattern(string=T.unsafe(nil), *keys, **filters); end

  def pattern_for(node, **options); end
end

class Mustermann::AST::Expander::NodeTranslator
end

class Mustermann::AST::Expander::NodeTranslator
  def self.translator(); end
end

class Mustermann::AST::Expander
end

class Mustermann::AST::Node
  def each_leaf(&block); end

  def initialize(payload=T.unsafe(nil), **options); end

  def is_a?(type); end

  def length(); end

  def min_size(); end

  def parse(); end

  def payload(); end

  def payload=(payload); end

  def start(); end

  def start=(start); end

  def stop(); end

  def stop=(stop); end

  def type(); end
end

class Mustermann::AST::Node::Capture
  def constraint(); end

  def constraint=(constraint); end

  def convert(); end

  def convert=(convert); end

  def name(); end

  def qualifier(); end

  def qualifier=(qualifier); end
end

class Mustermann::AST::Node::Capture
end

class Mustermann::AST::Node::Char
end

class Mustermann::AST::Node::Char
end

class Mustermann::AST::Node::Composition
end

class Mustermann::AST::Node::Composition
end

class Mustermann::AST::Node::Expression
  def operator(); end

  def operator=(operator); end
end

class Mustermann::AST::Node::Expression
end

class Mustermann::AST::Node::Group
end

class Mustermann::AST::Node::Group
end

class Mustermann::AST::Node::NamedSplat
end

class Mustermann::AST::Node::NamedSplat
end

class Mustermann::AST::Node::Optional
end

class Mustermann::AST::Node::Optional
end

class Mustermann::AST::Node::Or
end

class Mustermann::AST::Node::Or
end

class Mustermann::AST::Node::Root
  def pattern(); end

  def pattern=(pattern); end
end

class Mustermann::AST::Node::Root
  def self.parse(string, &block); end
end

class Mustermann::AST::Node::Separator
end

class Mustermann::AST::Node::Separator
end

class Mustermann::AST::Node::Splat
end

class Mustermann::AST::Node::Splat
end

class Mustermann::AST::Node::Union
end

class Mustermann::AST::Node::Union
end

class Mustermann::AST::Node::Variable
  def explode(); end

  def explode=(explode); end

  def prefix(); end

  def prefix=(prefix); end
end

class Mustermann::AST::Node::Variable
end

class Mustermann::AST::Node::WithLookAhead
  def at_end(); end

  def at_end=(at_end); end

  def head(); end

  def head=(head); end

  def initialize(payload, at_end, **options); end
end

class Mustermann::AST::Node::WithLookAhead
end

class Mustermann::AST::Node
  def self.[](name); end

  def self.constant_name(name); end

  def self.parse(*args, &block); end

  def self.type(); end
end

class Mustermann::AST::ParamScanner
end

class Mustermann::AST::ParamScanner::NodeTranslator
end

class Mustermann::AST::ParamScanner::NodeTranslator
  def self.translator(); end
end

class Mustermann::AST::ParamScanner
  def self.scan_params(ast); end
end

class Mustermann::AST::Parser
  def buffer(); end

  def default_node(char); end

  def eos?(*args, &block); end

  def expect(regexp, char: T.unsafe(nil), **options); end

  def getch(*args, &block); end

  def initialize(pattern: T.unsafe(nil), **options); end

  def min_size(start, stop, node); end

  def node(type, *args, &block); end

  def parse(string); end

  def pattern(); end

  def pos(*args, &block); end

  def read(); end

  def read_args(key_separator, close, separator: T.unsafe(nil), symbol_keys: T.unsafe(nil), **options); end

  def read_brackets(open, close, char: T.unsafe(nil), escape: T.unsafe(nil), quote: T.unsafe(nil), **options); end

  def read_escaped(close, escape: T.unsafe(nil), **options); end

  def read_list(*close, separator: T.unsafe(nil), escape: T.unsafe(nil), quotes: T.unsafe(nil), ignore: T.unsafe(nil), **options); end

  def read_suffix(element); end

  def scan(regexp); end

  def string(); end

  def unexpected(char=T.unsafe(nil), exception: T.unsafe(nil)); end
end

class Mustermann::AST::Parser
  extend ::Forwardable
  def self.on(*chars, &block); end

  def self.parse(string, **options); end

  def self.suffix(pattern=T.unsafe(nil), after: T.unsafe(nil), &block); end
end

class Mustermann::AST::Pattern
  def boundaries(*args, &block); end

  def compiler(*args, &block); end

  def param_scanner(*args, &block); end

  def parser(*args, &block); end

  def template_generator(*args, &block); end

  def to_ast(); end

  def transformer(*args, &block); end

  def validation(*args, &block); end
end

class Mustermann::AST::Pattern
  extend ::SingleForwardable
  def self.boundaries(); end

  def self.compiler(); end

  def self.on(*args, &block); end

  def self.param_scanner(); end

  def self.parser(); end

  def self.suffix(*args, &block); end

  def self.template_generator(); end

  def self.transformer(); end

  def self.validation(); end
end

class Mustermann::AST::TemplateGenerator
end

class Mustermann::AST::TemplateGenerator::NodeTranslator
end

class Mustermann::AST::TemplateGenerator::NodeTranslator
  def self.translator(); end
end

class Mustermann::AST::TemplateGenerator
  def self.generate_templates(ast); end
end

class Mustermann::AST::Transformer
end

class Mustermann::AST::Transformer::ArrayTransform
  def create_lookahead(elements, *args); end

  def expect_lookahead?(element); end

  def list_for(element); end

  def lookahead?(element, in_lookahead=T.unsafe(nil)); end

  def lookahead_buffer(); end

  def lookahead_payload?(payload, in_lookahead); end

  def payload(); end

  def track(element); end

  def translate(); end
end

class Mustermann::AST::Transformer::ArrayTransform
end

class Mustermann::AST::Transformer::ExpressionTransform
  def translate(); end
  OPERATORS = ::T.let(nil, ::T.untyped)
end

class Mustermann::AST::Transformer::ExpressionTransform::Operator
  def allow_reserved(); end

  def allow_reserved=(_); end

  def parametric(); end

  def parametric=(_); end

  def prefix(); end

  def prefix=(_); end

  def separator(); end

  def separator=(_); end
end

class Mustermann::AST::Transformer::ExpressionTransform::Operator
  def self.[](*_); end

  def self.members(); end
end

class Mustermann::AST::Transformer::ExpressionTransform
end

class Mustermann::AST::Transformer::GroupTransformer
  def group(elements); end

  def split_payload(); end

  def translate(); end

  def union(); end
end

class Mustermann::AST::Transformer::GroupTransformer
end

class Mustermann::AST::Transformer::NodeTranslator
end

class Mustermann::AST::Transformer::NodeTranslator
  def self.translator(); end
end

class Mustermann::AST::Transformer::RootTransformer
end

class Mustermann::AST::Transformer::RootTransformer
end

class Mustermann::AST::Transformer
  def self.transform(tree); end
end

class Mustermann::AST::Translator
  def decorator_for(node); end

  def error_class(); end

  def escape(char, parser: T.unsafe(nil), escape: T.unsafe(nil), also_escape: T.unsafe(nil)); end

  def translate(node, *args, &block); end
end

class Mustermann::AST::Translator::NodeTranslator
  def initialize(node, translator); end

  def node(); end

  def t(*args, &block); end

  def translator(); end
end

class Mustermann::AST::Translator::NodeTranslator
  def self.register(*types); end
end

class Mustermann::AST::Translator
  def self.create(&block); end

  def self.dispatch_table(); end

  def self.inherited(subclass); end

  def self.raises(error); end

  def self.translate(*types, &block); end
end

class Mustermann::AST::Validation
  def check_name(name, forbidden: T.unsafe(nil)); end

  def names(); end
end

class Mustermann::AST::Validation::NodeTranslator
end

class Mustermann::AST::Validation::NodeTranslator
  def self.translator(); end
end

class Mustermann::AST::Validation
  def self.validate(ast); end
end

module Mustermann::AST
end

class Mustermann::Caster
  def cast(hash); end

  def caster_for(type, &block); end

  def initialize(*types, &block); end

  def register(*types, &block); end
end

class Mustermann::Caster::Any
  def cast(key, value); end

  def initialize(&block); end
end

class Mustermann::Caster::Any
end

class Mustermann::Caster::Key
  def initialize(type, &block); end
end

class Mustermann::Caster::Key
end

class Mustermann::Caster::Value
  def initialize(type, &block); end
end

class Mustermann::Caster::Value
end

class Mustermann::Caster
end

class Mustermann::CompileError
end

class Mustermann::CompileError
end

class Mustermann::Composite
  def ==(pattern); end

  def eql?(pattern); end

  def initialize(patterns, operator: T.unsafe(nil), **options); end

  def operator(); end

  def params(string); end

  def patterns(); end
end

class Mustermann::Composite
  def self.new(*patterns, **options); end

  def self.supported?(option, type: T.unsafe(nil), **options); end
end

class Mustermann::Concat
  def initialize(*_); end
end

module Mustermann::Concat::Native
  def +(other); end

  def look_ahead(other); end
end

module Mustermann::Concat::Native
end

class Mustermann::Concat
end

class Mustermann::EqualityMap
  def fetch(key); end

  def map(); end
end

class Mustermann::EqualityMap
  def self.new(); end
end

class Mustermann::Error
end

class Mustermann::Error
end

class Mustermann::ExpandError
end

class Mustermann::ExpandError
end

class Mustermann::Expander
  def <<(*patterns); end

  def ==(other); end

  def add(*patterns); end

  def additional_values(); end

  def cast(*types, &block); end

  def eql?(other); end

  def expand(behavior=T.unsafe(nil), values=T.unsafe(nil)); end

  def expandable?(values); end

  def initialize(*patterns, additional_values: T.unsafe(nil), **options, &block); end

  def patterns(); end
end

class Mustermann::Expander
end

class Mustermann::Identity
  include ::Mustermann::Concat::Native
  def to_ast(); end
end

class Mustermann::Identity
end

class Mustermann::ParseError
end

class Mustermann::ParseError
end

class Mustermann::Pattern
  include ::Mustermann
  def &(other); end

  def +(other); end

  def ==(other); end

  def ===(string); end

  def =~(string); end

  def ^(other); end

  def always_array?(key); end

  def eql?(other); end

  def expand(behavior=T.unsafe(nil), values=T.unsafe(nil)); end

  def initialize(string, uri_decode: T.unsafe(nil), **options); end

  def match(string); end

  def named_captures(); end

  def names(); end

  def options(); end

  def params(string=T.unsafe(nil), captures: T.unsafe(nil), offset: T.unsafe(nil)); end

  def peek(string); end

  def peek_match(string); end

  def peek_params(string); end

  def peek_size(string); end

  def respond_to?(method, *args); end

  def simple_inspect(); end

  def to_proc(); end

  def to_templates(); end

  def uri_decode(); end

  def |(other); end
end

class Mustermann::Pattern
  def self.new(string, ignore_unknown_options: T.unsafe(nil), **options); end

  def self.register(*names); end

  def self.supported?(option, **options); end

  def self.supported_options(*list); end
end

class Mustermann::RegexpBased
  def ===(*args, &block); end

  def =~(*args, &block); end

  def initialize(string, **options); end

  def match(*args, &block); end

  def named_captures(*args, &block); end

  def names(*args, &block); end

  def regexp(); end

  def to_regexp(); end
end

class Mustermann::RegexpBased
  extend ::Forwardable
end

class Mustermann::Regular
  include ::Mustermann::Concat::Native
  def initialize(string, check_anchors: T.unsafe(nil), **options); end
end

class Mustermann::Regular
end

class Mustermann::SimpleMatch
  def +(other); end

  def [](*args); end

  def captures(); end

  def initialize(string=T.unsafe(nil), names: T.unsafe(nil), captures: T.unsafe(nil)); end

  def names(); end
end

class Mustermann::SimpleMatch
end

class Mustermann::Sinatra
  include ::Mustermann::Concat::Native
  def safe_string(); end
end

class Mustermann::Sinatra
  def self.escape(string); end

  def self.try_convert(input, **options); end
end

module Mustermann
  def self.[](name); end

  def self.extend_object(object); end

  def self.new(*input, type: T.unsafe(nil), operator: T.unsafe(nil), **options); end

  def self.normalized_type(type); end

  def self.register(name, type); end

  def self.try_require(path); end
end

class NameError
  def name(); end

  def receiver(); end
end

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

class Net::HTTPClientError
end

Net::HTTPClientErrorCode::EXCEPTION_TYPE = Net::HTTPServerException

class Net::HTTPClientError
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPInformation
end

Net::HTTPInformationCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPInformation
end

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRedirection
end

Net::HTTPRedirectionCode::EXCEPTION_TYPE = Net::HTTPRetriableError

class Net::HTTPRedirection
end

Net::HTTPRequestURITooLarge = Net::HTTPRequestURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

class Net::HTTPServerError
end

Net::HTTPServerErrorCode::EXCEPTION_TYPE = Net::HTTPFatalError

class Net::HTTPServerError
end

class Net::HTTP
end

Net::HTTPSession::ProxyDelta = Net::HTTP::ProxyDelta

Net::HTTPSession::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTP
end

class Net::HTTPSuccess
end

Net::HTTPSuccessCode::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPSuccess
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_i(); end
end

class NoMethodError
  def args(); end

  def private_call?(); end
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class ObjectSpace::WeakMap
  def [](_); end

  def []=(_, _1); end

  def each(&blk); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

module ObjectSpace
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

module Octokit
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Octokit::AbuseDetected
end

class Octokit::AbuseDetected
end

class Octokit::AccountSuspended
end

class Octokit::AccountSuspended
end

class Octokit::ApplicationCredentialsRequired
end

class Octokit::ApplicationCredentialsRequired
end

class Octokit::Arguments
  def initialize(args); end

  def options(); end
end

class Octokit::Arguments
end

module Octokit::Authentication
  def application_authenticated?(); end

  def basic_authenticated?(); end

  def bearer_authenticated?(); end

  def token_authenticated?(); end

  def user_authenticated?(); end
end

module Octokit::Authentication
end

class Octokit::BadGateway
end

class Octokit::BadGateway
end

class Octokit::BadRequest
end

class Octokit::BadRequest
end

class Octokit::BranchNotProtected
end

class Octokit::BranchNotProtected
end

class Octokit::Client
  include ::Octokit::Configurable
  include ::Octokit::Connection
  include ::Octokit::Authentication
  include ::Octokit::Preview
  include ::Octokit::Warnable
  include ::Octokit::Client::Authorizations
  include ::Octokit::Client::Checks
  include ::Octokit::Client::Commits
  include ::Octokit::Client::CommitComments
  include ::Octokit::Client::CommunityProfile
  include ::Octokit::Client::Contents
  include ::Octokit::Client::Deployments
  include ::Octokit::Client::Downloads
  include ::Octokit::Client::Emojis
  include ::Octokit::Client::Events
  include ::Octokit::Client::Feeds
  include ::Octokit::Client::Gists
  include ::Octokit::Client::Gitignore
  include ::Octokit::Client::Hooks
  include ::Octokit::Client::Apps
  include ::Octokit::Client::Issues
  include ::Octokit::Client::Labels
  include ::Octokit::Client::LegacySearch
  include ::Octokit::Client::Licenses
  include ::Octokit::Client::Meta
  include ::Octokit::Client::Markdown
  include ::Octokit::Client::Marketplace
  include ::Octokit::Client::Milestones
  include ::Octokit::Client::Notifications
  include ::Octokit::Client::Objects
  include ::Octokit::Client::Organizations
  include ::Octokit::Client::Pages
  include ::Octokit::Client::Projects
  include ::Octokit::Client::PubSubHubbub
  include ::Octokit::Client::PullRequests
  include ::Octokit::Client::RateLimit
  include ::Octokit::Client::Reactions
  include ::Octokit::Client::Refs
  include ::Octokit::Client::Releases
  include ::Octokit::Client::Repositories
  include ::Octokit::Client::RepositoryInvitations
  include ::Octokit::Client::Reviews
  include ::Octokit::Client::Say
  include ::Octokit::Client::Search
  include ::Octokit::Client::ServiceStatus
  include ::Octokit::Client::SourceImport
  include ::Octokit::Client::Stats
  include ::Octokit::Client::Statuses
  include ::Octokit::Client::Traffic
  include ::Octokit::Client::Users
  def access_token=(value); end

  def as_app(key=T.unsafe(nil), secret=T.unsafe(nil), &block); end

  def bearer_token=(value); end

  def client_id=(value); end

  def client_secret=(value); end

  def client_without_redirects(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def login=(value); end

  def password=(value); end
  CONVENIENCE_HEADERS = ::T.let(nil, ::T.untyped)
end

module Octokit::Client::Apps
  def add_repo_to_installation(installation, repo, options=T.unsafe(nil)); end

  def add_repository_to_app_installation(installation, repo, options=T.unsafe(nil)); end

  def add_repository_to_integration_installation(installation, repo, options=T.unsafe(nil)); end

  def create_app_installation_access_token(installation, options=T.unsafe(nil)); end

  def create_installation_access_token(installation, options=T.unsafe(nil)); end

  def create_integration_installation_access_token(installation, options=T.unsafe(nil)); end

  def find_app_installations(options=T.unsafe(nil)); end

  def find_installation_repositories_for_user(installation, options=T.unsafe(nil)); end

  def find_installations(options=T.unsafe(nil)); end

  def find_integration_installations(options=T.unsafe(nil)); end

  def find_organization_installation(organization, options=T.unsafe(nil)); end

  def find_repository_installation(repo, options=T.unsafe(nil)); end

  def find_user_installation(user, options=T.unsafe(nil)); end

  def find_user_installations(options=T.unsafe(nil)); end

  def installation(id, options=T.unsafe(nil)); end

  def list_app_installation_repositories(options=T.unsafe(nil)); end

  def list_installation_repos(options=T.unsafe(nil)); end

  def list_integration_installation_repositories(options=T.unsafe(nil)); end

  def remove_repo_from_installation(installation, repo, options=T.unsafe(nil)); end

  def remove_repository_from_app_installation(installation, repo, options=T.unsafe(nil)); end

  def remove_repository_from_integration_installation(installation, repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Apps
end

module Octokit::Client::Authorizations
  def authorization(number, options=T.unsafe(nil)); end

  def authorizations(options=T.unsafe(nil)); end

  def authorize_url(app_id=T.unsafe(nil), options=T.unsafe(nil)); end

  def check_application_authorization(token, options=T.unsafe(nil)); end

  def create_authorization(options=T.unsafe(nil)); end

  def delete_application_authorization(token, options=T.unsafe(nil)); end

  def delete_authorization(number, options=T.unsafe(nil)); end

  def reset_application_authorization(token, options=T.unsafe(nil)); end

  def revoke_all_application_authorizations(options=T.unsafe(nil)); end

  def revoke_application_authorization(token, options=T.unsafe(nil)); end

  def scopes(token=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_authorization(number, options=T.unsafe(nil)); end
end

module Octokit::Client::Authorizations
end

module Octokit::Client::Checks
  def check_run(repo, id, options=T.unsafe(nil)); end

  def check_run_annotations(repo, id, options=T.unsafe(nil)); end

  def check_runs_for_check_suite(repo, id, options=T.unsafe(nil)); end

  def check_runs_for_ref(repo, ref, options=T.unsafe(nil)); end

  def check_suite(repo, id, options=T.unsafe(nil)); end

  def check_suites_for_ref(repo, ref, options=T.unsafe(nil)); end

  def create_check_run(repo, name, head_sha, options=T.unsafe(nil)); end

  def create_check_suite(repo, head_sha, options=T.unsafe(nil)); end

  def list_check_runs_for_check_suite(repo, id, options=T.unsafe(nil)); end

  def list_check_runs_for_ref(repo, ref, options=T.unsafe(nil)); end

  def list_check_suites_for_ref(repo, ref, options=T.unsafe(nil)); end

  def rerequest_check_suite(repo, id, options=T.unsafe(nil)); end

  def set_check_suite_preferences(repo, options=T.unsafe(nil)); end

  def update_check_run(repo, id, options=T.unsafe(nil)); end
end

module Octokit::Client::Checks
end

module Octokit::Client::CommitComments
  def commit_comment(repo, id, options=T.unsafe(nil)); end

  def commit_comments(repo, sha, options=T.unsafe(nil)); end

  def create_commit_comment(repo, sha, body, path=T.unsafe(nil), line=T.unsafe(nil), position=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_commit_comment(repo, id, options=T.unsafe(nil)); end

  def list_commit_comments(repo, options=T.unsafe(nil)); end

  def update_commit_comment(repo, id, body, options=T.unsafe(nil)); end
end

module Octokit::Client::CommitComments
end

module Octokit::Client::Commits
  def commit(repo, sha, options=T.unsafe(nil)); end

  def commits(*args); end

  def commits_before(*args); end

  def commits_between(*args); end

  def commits_on(*args); end

  def commits_since(*args); end

  def compare(repo, start, endd, options=T.unsafe(nil)); end

  def create_commit(repo, message, tree, parents=T.unsafe(nil), options=T.unsafe(nil)); end

  def git_commit(repo, sha, options=T.unsafe(nil)); end

  def iso8601(date); end

  def list_commits(*args); end

  def merge(repo, base, head, options=T.unsafe(nil)); end

  def parse_date(date); end
end

module Octokit::Client::Commits
end

module Octokit::Client::CommunityProfile
  def community_profile(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::CommunityProfile
end

module Octokit::Client::Contents
  def add_content(*args); end

  def add_contents(*args); end

  def archive_link(repo, options=T.unsafe(nil)); end

  def content(repo, options=T.unsafe(nil)); end

  def contents(repo, options=T.unsafe(nil)); end

  def create_content(*args); end

  def create_contents(*args); end

  def delete_content(repo, path, message, sha, options=T.unsafe(nil)); end

  def delete_contents(repo, path, message, sha, options=T.unsafe(nil)); end

  def readme(repo, options=T.unsafe(nil)); end

  def remove_content(repo, path, message, sha, options=T.unsafe(nil)); end

  def remove_contents(repo, path, message, sha, options=T.unsafe(nil)); end

  def update_content(*args); end

  def update_contents(*args); end
end

module Octokit::Client::Contents
end

module Octokit::Client::Deployments
  def create_deployment(repo, ref, options=T.unsafe(nil)); end

  def create_deployment_status(deployment_url, state, options=T.unsafe(nil)); end

  def deployment(repo, deployment_id, options=T.unsafe(nil)); end

  def deployment_statuses(deployment_url, options=T.unsafe(nil)); end

  def deployments(repo, options=T.unsafe(nil)); end

  def list_deployment_statuses(deployment_url, options=T.unsafe(nil)); end

  def list_deployments(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Deployments
end

module Octokit::Client::Downloads
  def delete_download(repo, id, options=T.unsafe(nil)); end

  def download(repo, id, options=T.unsafe(nil)); end

  def downloads(repo, options=T.unsafe(nil)); end

  def list_downloads(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Downloads
end

module Octokit::Client::Emojis
  def emojis(options=T.unsafe(nil)); end
end

module Octokit::Client::Emojis
end

module Octokit::Client::Events
  def issue_event(repo, number, options=T.unsafe(nil)); end

  def issue_events(repo, number, options=T.unsafe(nil)); end

  def organization_events(org, options=T.unsafe(nil)); end

  def organization_public_events(org, options=T.unsafe(nil)); end

  def public_events(options=T.unsafe(nil)); end

  def received_events(user, options=T.unsafe(nil)); end

  def received_public_events(user, options=T.unsafe(nil)); end

  def repo_issue_events(repo, options=T.unsafe(nil)); end

  def repository_events(repo, options=T.unsafe(nil)); end

  def repository_issue_events(repo, options=T.unsafe(nil)); end

  def repository_network_events(repo, options=T.unsafe(nil)); end

  def user_events(user, options=T.unsafe(nil)); end

  def user_public_events(user, options=T.unsafe(nil)); end
end

module Octokit::Client::Events
end

module Octokit::Client::Feeds
  def feed(name, options=T.unsafe(nil)); end

  def feeds(); end
end

module Octokit::Client::Feeds
end

module Octokit::Client::Gists
  def create_gist(options=T.unsafe(nil)); end

  def create_gist_comment(gist_id, comment, options=T.unsafe(nil)); end

  def delete_gist(gist, options=T.unsafe(nil)); end

  def delete_gist_comment(gist_id, gist_comment_id, options=T.unsafe(nil)); end

  def edit_gist(gist, options=T.unsafe(nil)); end

  def fork_gist(gist, options=T.unsafe(nil)); end

  def gist(gist, options=T.unsafe(nil)); end

  def gist_comment(gist_id, gist_comment_id, options=T.unsafe(nil)); end

  def gist_comments(gist_id, options=T.unsafe(nil)); end

  def gist_commits(gist, options=T.unsafe(nil)); end

  def gist_forks(gist, options=T.unsafe(nil)); end

  def gist_starred?(gist, options=T.unsafe(nil)); end

  def gists(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_gists(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def public_gists(options=T.unsafe(nil)); end

  def star_gist(gist, options=T.unsafe(nil)); end

  def starred_gists(options=T.unsafe(nil)); end

  def unstar_gist(gist, options=T.unsafe(nil)); end

  def update_gist_comment(gist_id, gist_comment_id, comment, options=T.unsafe(nil)); end
end

module Octokit::Client::Gists
end

module Octokit::Client::Gitignore
  def gitignore_template(template_name, options=T.unsafe(nil)); end

  def gitignore_templates(options=T.unsafe(nil)); end
end

module Octokit::Client::Gitignore
end

module Octokit::Client::Hooks
  def available_hooks(options=T.unsafe(nil)); end

  def create_hook(repo, name, config, options=T.unsafe(nil)); end

  def create_org_hook(org, config, options=T.unsafe(nil)); end

  def edit_hook(repo, id, name, config, options=T.unsafe(nil)); end

  def edit_org_hook(org, id, config, options=T.unsafe(nil)); end

  def hook(repo, id, options=T.unsafe(nil)); end

  def hooks(repo, options=T.unsafe(nil)); end

  def list_org_hooks(org, options=T.unsafe(nil)); end

  def org_hook(org, id, options=T.unsafe(nil)); end

  def org_hooks(org, options=T.unsafe(nil)); end

  def parse_payload(payload_string); end

  def ping_hook(repo, id, options=T.unsafe(nil)); end

  def ping_org_hook(org, id, options=T.unsafe(nil)); end

  def remove_hook(repo, id, options=T.unsafe(nil)); end

  def remove_org_hook(org, id, options=T.unsafe(nil)); end

  def test_hook(repo, id, options=T.unsafe(nil)); end

  def update_org_hook(org, id, config, options=T.unsafe(nil)); end
end

module Octokit::Client::Hooks
end

module Octokit::Client::Issues
  def add_assignees(repo, number, assignees, options=T.unsafe(nil)); end

  def add_comment(repo, number, comment, options=T.unsafe(nil)); end

  def close_issue(repo, number, options=T.unsafe(nil)); end

  def create_issue(repo, title, body=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_comment(repo, number, options=T.unsafe(nil)); end

  def issue(repo, number, options=T.unsafe(nil)); end

  def issue_comment(repo, number, options=T.unsafe(nil)); end

  def issue_comments(repo, number, options=T.unsafe(nil)); end

  def issue_timeline(repo, number, options=T.unsafe(nil)); end

  def issues(repository=T.unsafe(nil), options=T.unsafe(nil)); end

  def issues_comments(repo, options=T.unsafe(nil)); end

  def list_assignees(repo, options=T.unsafe(nil)); end

  def list_issues(repository=T.unsafe(nil), options=T.unsafe(nil)); end

  def lock_issue(repo, number, options=T.unsafe(nil)); end

  def open_issue(repo, title, body=T.unsafe(nil), options=T.unsafe(nil)); end

  def org_issues(org, options=T.unsafe(nil)); end

  def remove_assignees(repo, number, assignees, options=T.unsafe(nil)); end

  def reopen_issue(repo, number, options=T.unsafe(nil)); end

  def unlock_issue(repo, number, options=T.unsafe(nil)); end

  def update_comment(repo, number, comment, options=T.unsafe(nil)); end

  def update_issue(repo, number, *args); end

  def user_issues(options=T.unsafe(nil)); end
end

module Octokit::Client::Issues
end

module Octokit::Client::Labels
  def add_label(repo, label, color=T.unsafe(nil), options=T.unsafe(nil)); end

  def add_labels_to_an_issue(repo, number, labels); end

  def delete_label!(repo, label, options=T.unsafe(nil)); end

  def label(repo, name, options=T.unsafe(nil)); end

  def labels(repo, options=T.unsafe(nil)); end

  def labels_for_issue(repo, number, options=T.unsafe(nil)); end

  def labels_for_milestone(repo, number, options=T.unsafe(nil)); end

  def remove_all_labels(repo, number, options=T.unsafe(nil)); end

  def remove_label(repo, number, label, options=T.unsafe(nil)); end

  def replace_all_labels(repo, number, labels, options=T.unsafe(nil)); end

  def update_label(repo, label, options=T.unsafe(nil)); end
end

module Octokit::Client::Labels
end

module Octokit::Client::LegacySearch
  def legacy_search_issues(repo, search_term, state=T.unsafe(nil), options=T.unsafe(nil)); end

  def legacy_search_repositories(q, options=T.unsafe(nil)); end

  def legacy_search_users(search, options=T.unsafe(nil)); end
end

module Octokit::Client::LegacySearch
end

module Octokit::Client::Licenses
  def license(license_name, options=T.unsafe(nil)); end

  def licenses(options=T.unsafe(nil)); end

  def repository_license_contents(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Licenses
end

module Octokit::Client::Markdown
  def markdown(text, options=T.unsafe(nil)); end
end

module Octokit::Client::Markdown
end

module Octokit::Client::Marketplace
  def list_accounts_for_plan(plan_id, options=T.unsafe(nil)); end

  def list_plans(options=T.unsafe(nil)); end

  def marketplace_purchases(options=T.unsafe(nil)); end

  def plan_for_account(account_id, options=T.unsafe(nil)); end
end

module Octokit::Client::Marketplace
end

module Octokit::Client::Meta
  def github_meta(options=T.unsafe(nil)); end

  def meta(options=T.unsafe(nil)); end
end

module Octokit::Client::Meta
end

module Octokit::Client::Milestones
  def create_milestone(repository, title, options=T.unsafe(nil)); end

  def delete_milestone(repository, number, options=T.unsafe(nil)); end

  def edit_milestone(repository, number, options=T.unsafe(nil)); end

  def list_milestones(repository, options=T.unsafe(nil)); end

  def milestone(repository, number, options=T.unsafe(nil)); end

  def milestones(repository, options=T.unsafe(nil)); end

  def update_milestone(repository, number, options=T.unsafe(nil)); end
end

module Octokit::Client::Milestones
end

module Octokit::Client::Notifications
  def delete_thread_subscription(thread_id, options=T.unsafe(nil)); end

  def mark_notifications_as_read(options=T.unsafe(nil)); end

  def mark_repo_notifications_as_read(repo, options=T.unsafe(nil)); end

  def mark_repository_notifications_as_read(repo, options=T.unsafe(nil)); end

  def mark_thread_as_read(thread_id, options=T.unsafe(nil)); end

  def notifications(options=T.unsafe(nil)); end

  def repo_notifications(repo, options=T.unsafe(nil)); end

  def repository_notifications(repo, options=T.unsafe(nil)); end

  def thread_notifications(thread_id, options=T.unsafe(nil)); end

  def thread_subscription(thread_id, options=T.unsafe(nil)); end

  def update_thread_subscription(thread_id, options=T.unsafe(nil)); end
end

module Octokit::Client::Notifications
end

module Octokit::Client::Objects
  def blob(repo, blob_sha, options=T.unsafe(nil)); end

  def create_blob(repo, content, encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_tag(repo, tag, message, object_sha, type, tagger_name, tagger_email, tagger_date, options=T.unsafe(nil)); end

  def create_tree(repo, tree, options=T.unsafe(nil)); end

  def tag(repo, tag_sha, options=T.unsafe(nil)); end

  def tree(repo, tree_sha, options=T.unsafe(nil)); end
end

module Octokit::Client::Objects
end

module Octokit::Client::Organizations
  def add_team_member(team_id, user, options=T.unsafe(nil)); end

  def add_team_membership(team_id, user, options=T.unsafe(nil)); end

  def add_team_repo(team_id, repo, options=T.unsafe(nil)); end

  def add_team_repository(team_id, repo, options=T.unsafe(nil)); end

  def all_organizations(options=T.unsafe(nil)); end

  def all_orgs(options=T.unsafe(nil)); end

  def child_teams(team_id, options=T.unsafe(nil)); end

  def conceal_membership(org, user, options=T.unsafe(nil)); end

  def convert_to_outside_collaborator(org, user, options=T.unsafe(nil)); end

  def create_team(org, options=T.unsafe(nil)); end

  def delete_migration_archive(org, id, options=T.unsafe(nil)); end

  def delete_team(team_id, options=T.unsafe(nil)); end

  def list_organizations(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_orgs(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def migration_archive_url(org, id, options=T.unsafe(nil)); end

  def migration_status(org, id, options=T.unsafe(nil)); end

  def migrations(org, options=T.unsafe(nil)); end

  def org(org, options=T.unsafe(nil)); end

  def org_invitations(org, options=T.unsafe(nil)); end

  def org_member?(org, user, options=T.unsafe(nil)); end

  def org_members(org, options=T.unsafe(nil)); end

  def org_membership(org, options=T.unsafe(nil)); end

  def org_memberships(options=T.unsafe(nil)); end

  def org_public_member?(org, user, options=T.unsafe(nil)); end

  def org_public_members(org, options=T.unsafe(nil)); end

  def org_repos(org, options=T.unsafe(nil)); end

  def org_repositories(org, options=T.unsafe(nil)); end

  def org_teams(org, options=T.unsafe(nil)); end

  def organization(org, options=T.unsafe(nil)); end

  def organization_invitations(org, options=T.unsafe(nil)); end

  def organization_member?(org, user, options=T.unsafe(nil)); end

  def organization_members(org, options=T.unsafe(nil)); end

  def organization_membership(org, options=T.unsafe(nil)); end

  def organization_memberships(options=T.unsafe(nil)); end

  def organization_public_member?(org, user, options=T.unsafe(nil)); end

  def organization_public_members(org, options=T.unsafe(nil)); end

  def organization_repositories(org, options=T.unsafe(nil)); end

  def organization_teams(org, options=T.unsafe(nil)); end

  def organizations(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def orgs(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def outside_collaborators(org, options=T.unsafe(nil)); end

  def publicize_membership(org, user, options=T.unsafe(nil)); end

  def remove_org_member(org, user, options=T.unsafe(nil)); end

  def remove_org_membership(org, options=T.unsafe(nil)); end

  def remove_organization_member(org, user, options=T.unsafe(nil)); end

  def remove_organization_membership(org, options=T.unsafe(nil)); end

  def remove_outside_collaborator(org, user, options=T.unsafe(nil)); end

  def remove_team_member(team_id, user, options=T.unsafe(nil)); end

  def remove_team_membership(team_id, user, options=T.unsafe(nil)); end

  def remove_team_repo(team_id, repo, options=T.unsafe(nil)); end

  def remove_team_repository(team_id, repo, options=T.unsafe(nil)); end

  def start_migration(org, repositories, options=T.unsafe(nil)); end

  def team(team_id, options=T.unsafe(nil)); end

  def team_invitations(team_id, options=T.unsafe(nil)); end

  def team_member?(team_id, user, options=T.unsafe(nil)); end

  def team_members(team_id, options=T.unsafe(nil)); end

  def team_membership(team_id, user, options=T.unsafe(nil)); end

  def team_repo?(team_id, repo, options=T.unsafe(nil)); end

  def team_repos(team_id, options=T.unsafe(nil)); end

  def team_repositories(team_id, options=T.unsafe(nil)); end

  def team_repository?(team_id, repo, options=T.unsafe(nil)); end

  def unlock_repository(org, id, repo, options=T.unsafe(nil)); end

  def unpublicize_membership(org, user, options=T.unsafe(nil)); end

  def update_org(org, values, options=T.unsafe(nil)); end

  def update_org_membership(org, options=T.unsafe(nil)); end

  def update_organization(org, values, options=T.unsafe(nil)); end

  def update_organization_membership(org, options=T.unsafe(nil)); end

  def update_team(team_id, options=T.unsafe(nil)); end

  def user_teams(options=T.unsafe(nil)); end
end

module Octokit::Client::Organizations
end

module Octokit::Client::Pages
  def latest_pages_build(repo, options=T.unsafe(nil)); end

  def list_pages_builds(repo, options=T.unsafe(nil)); end

  def pages(repo, options=T.unsafe(nil)); end

  def pages_build(repo, id, options=T.unsafe(nil)); end

  def pages_builds(repo, options=T.unsafe(nil)); end

  def request_page_build(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Pages
end

module Octokit::Client::Projects
  def column_cards(id, options=T.unsafe(nil)); end

  def create_org_project(org, name, options=T.unsafe(nil)); end

  def create_organization_project(org, name, options=T.unsafe(nil)); end

  def create_project(repo, name, options=T.unsafe(nil)); end

  def create_project_card(id, options=T.unsafe(nil)); end

  def create_project_column(id, name, options=T.unsafe(nil)); end

  def delete_project(id, options=T.unsafe(nil)); end

  def delete_project_card(id, options=T.unsafe(nil)); end

  def delete_project_column(id, options=T.unsafe(nil)); end

  def move_project_card(id, position, options=T.unsafe(nil)); end

  def move_project_column(id, position, options=T.unsafe(nil)); end

  def org_projects(org, options=T.unsafe(nil)); end

  def organization_projects(org, options=T.unsafe(nil)); end

  def project(id, options=T.unsafe(nil)); end

  def project_card(id, options=T.unsafe(nil)); end

  def project_column(id, options=T.unsafe(nil)); end

  def project_columns(id, options=T.unsafe(nil)); end

  def projects(repo, options=T.unsafe(nil)); end

  def update_project(id, options=T.unsafe(nil)); end

  def update_project_card(id, options=T.unsafe(nil)); end

  def update_project_column(id, name, options=T.unsafe(nil)); end
end

module Octokit::Client::Projects
end

module Octokit::Client::PubSubHubbub
  def subscribe(topic, callback, secret=T.unsafe(nil)); end

  def subscribe_service_hook(repo, service_name, service_arguments=T.unsafe(nil), secret=T.unsafe(nil)); end

  def unsubscribe(topic, callback); end

  def unsubscribe_service_hook(repo, service_name); end
end

module Octokit::Client::PubSubHubbub
end

module Octokit::Client::PullRequests
  def close_pull_request(repo, number, options=T.unsafe(nil)); end

  def create_pull_comment(repo, pull_id, body, commit_id, path, position, options=T.unsafe(nil)); end

  def create_pull_reply(repo, pull_id, body, comment_id, options=T.unsafe(nil)); end

  def create_pull_request(repo, base, head, title, body=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_pull_request_comment(repo, pull_id, body, commit_id, path, position, options=T.unsafe(nil)); end

  def create_pull_request_comment_reply(repo, pull_id, body, comment_id, options=T.unsafe(nil)); end

  def create_pull_request_for_issue(repo, base, head, issue, options=T.unsafe(nil)); end

  def create_review_reply(repo, pull_id, body, comment_id, options=T.unsafe(nil)); end

  def create_view_comment(repo, pull_id, body, commit_id, path, position, options=T.unsafe(nil)); end

  def delete_pull_comment(repo, comment_id, options=T.unsafe(nil)); end

  def delete_pull_request_comment(repo, comment_id, options=T.unsafe(nil)); end

  def delete_review_comment(repo, comment_id, options=T.unsafe(nil)); end

  def merge_pull_request(repo, number, commit_message=T.unsafe(nil), options=T.unsafe(nil)); end

  def pull(repo, number, options=T.unsafe(nil)); end

  def pull_comment(repo, comment_id, options=T.unsafe(nil)); end

  def pull_comments(repo, number, options=T.unsafe(nil)); end

  def pull_commits(repo, number, options=T.unsafe(nil)); end

  def pull_files(repo, number, options=T.unsafe(nil)); end

  def pull_merged?(repo, number, options=T.unsafe(nil)); end

  def pull_request(repo, number, options=T.unsafe(nil)); end

  def pull_request_comment(repo, comment_id, options=T.unsafe(nil)); end

  def pull_request_comments(repo, number, options=T.unsafe(nil)); end

  def pull_request_commits(repo, number, options=T.unsafe(nil)); end

  def pull_request_files(repo, number, options=T.unsafe(nil)); end

  def pull_request_merged?(repo, number, options=T.unsafe(nil)); end

  def pull_requests(repo, options=T.unsafe(nil)); end

  def pull_requests_comments(repo, options=T.unsafe(nil)); end

  def pulls(repo, options=T.unsafe(nil)); end

  def pulls_comments(repo, options=T.unsafe(nil)); end

  def review_comment(repo, comment_id, options=T.unsafe(nil)); end

  def review_comments(repo, number, options=T.unsafe(nil)); end

  def reviews_comments(repo, options=T.unsafe(nil)); end

  def update_pull_comment(repo, comment_id, body, options=T.unsafe(nil)); end

  def update_pull_request(*args); end

  def update_pull_request_comment(repo, comment_id, body, options=T.unsafe(nil)); end

  def update_review_comment(repo, comment_id, body, options=T.unsafe(nil)); end
end

module Octokit::Client::PullRequests
end

module Octokit::Client::RateLimit
  def rate_limit(options=T.unsafe(nil)); end

  def rate_limit!(options=T.unsafe(nil)); end

  def rate_limit_remaining(options=T.unsafe(nil)); end

  def rate_limit_remaining!(options=T.unsafe(nil)); end

  def ratelimit(options=T.unsafe(nil)); end

  def ratelimit!(options=T.unsafe(nil)); end

  def ratelimit_remaining(options=T.unsafe(nil)); end

  def ratelimit_remaining!(options=T.unsafe(nil)); end
end

module Octokit::Client::RateLimit
end

module Octokit::Client::Reactions
  def commit_comment_reactions(repo, id, options=T.unsafe(nil)); end

  def create_commit_comment_reaction(repo, id, reaction, options=T.unsafe(nil)); end

  def create_issue_comment_reaction(repo, id, reaction, options=T.unsafe(nil)); end

  def create_issue_reaction(repo, number, reaction, options=T.unsafe(nil)); end

  def create_pull_request_review_comment_reaction(repo, id, reaction, options=T.unsafe(nil)); end

  def delete_reaction(id, options=T.unsafe(nil)); end

  def issue_comment_reactions(repo, id, options=T.unsafe(nil)); end

  def issue_reactions(repo, number, options=T.unsafe(nil)); end

  def pull_request_review_comment_reactions(repo, id, options=T.unsafe(nil)); end
end

module Octokit::Client::Reactions
end

module Octokit::Client::Refs
  def create_ref(repo, ref, sha, options=T.unsafe(nil)); end

  def create_reference(repo, ref, sha, options=T.unsafe(nil)); end

  def delete_branch(repo, branch, options=T.unsafe(nil)); end

  def delete_ref(repo, ref, options=T.unsafe(nil)); end

  def delete_reference(repo, ref, options=T.unsafe(nil)); end

  def list_references(repo, namespace=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_refs(repo, namespace=T.unsafe(nil), options=T.unsafe(nil)); end

  def ref(repo, ref, options=T.unsafe(nil)); end

  def reference(repo, ref, options=T.unsafe(nil)); end

  def references(repo, namespace=T.unsafe(nil), options=T.unsafe(nil)); end

  def refs(repo, namespace=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_branch(repo, branch, sha, force=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_ref(repo, ref, sha, force=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_reference(repo, ref, sha, force=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Octokit::Client::Refs
end

module Octokit::Client::Releases
  def create_release(repo, tag_name, options=T.unsafe(nil)); end

  def delete_release(url, options=T.unsafe(nil)); end

  def delete_release_asset(asset_url, options=T.unsafe(nil)); end

  def edit_release(url, options=T.unsafe(nil)); end

  def edit_release_asset(asset_url, options=T.unsafe(nil)); end

  def latest_release(repo, options=T.unsafe(nil)); end

  def list_releases(repo, options=T.unsafe(nil)); end

  def release(url, options=T.unsafe(nil)); end

  def release_asset(asset_url, options=T.unsafe(nil)); end

  def release_assets(release_url, options=T.unsafe(nil)); end

  def release_for_tag(repo, tag_name, options=T.unsafe(nil)); end

  def releases(repo, options=T.unsafe(nil)); end

  def update_release(url, options=T.unsafe(nil)); end

  def update_release_asset(asset_url, options=T.unsafe(nil)); end

  def upload_asset(release_url, path_or_file, options=T.unsafe(nil)); end
end

module Octokit::Client::Releases
end

module Octokit::Client::Repositories
  def add_collab(repo, collaborator, options=T.unsafe(nil)); end

  def add_collaborator(repo, collaborator, options=T.unsafe(nil)); end

  def add_deploy_key(repo, title, key, options=T.unsafe(nil)); end

  def all_repositories(options=T.unsafe(nil)); end

  def branch(repo, branch, options=T.unsafe(nil)); end

  def branch_protection(repo, branch, options=T.unsafe(nil)); end

  def branches(repo, options=T.unsafe(nil)); end

  def check_assignee(repo, assignee, options=T.unsafe(nil)); end

  def collaborator?(repo, collaborator, options=T.unsafe(nil)); end

  def collaborators(repo, options=T.unsafe(nil)); end

  def collabs(repo, options=T.unsafe(nil)); end

  def contribs(repo, anon=T.unsafe(nil), options=T.unsafe(nil)); end

  def contributors(repo, anon=T.unsafe(nil), options=T.unsafe(nil)); end

  def create(name, options=T.unsafe(nil)); end

  def create_repo(name, options=T.unsafe(nil)); end

  def create_repository(name, options=T.unsafe(nil)); end

  def delete_repo(repo, options=T.unsafe(nil)); end

  def delete_repository(repo, options=T.unsafe(nil)); end

  def delete_subscription(repo, options=T.unsafe(nil)); end

  def deploy_key(repo, id, options=T.unsafe(nil)); end

  def deploy_keys(repo, options=T.unsafe(nil)); end

  def edit(repo, options=T.unsafe(nil)); end

  def edit_deploy_key(repo, id, options); end

  def edit_repository(repo, options=T.unsafe(nil)); end

  def fork(repo, options=T.unsafe(nil)); end

  def forks(repo, options=T.unsafe(nil)); end

  def get_branch(repo, branch, options=T.unsafe(nil)); end

  def languages(repo, options=T.unsafe(nil)); end

  def list_deploy_keys(repo, options=T.unsafe(nil)); end

  def list_repos(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_repositories(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def network(repo, options=T.unsafe(nil)); end

  def permission_level(repo, collaborator, options=T.unsafe(nil)); end

  def protect_branch(repo, branch, options=T.unsafe(nil)); end

  def remove_collab(repo, collaborator, options=T.unsafe(nil)); end

  def remove_collaborator(repo, collaborator, options=T.unsafe(nil)); end

  def remove_deploy_key(repo, id, options=T.unsafe(nil)); end

  def replace_all_topics(repo, names, options=T.unsafe(nil)); end

  def repo(repo, options=T.unsafe(nil)); end

  def repo_assignees(repo, options=T.unsafe(nil)); end

  def repo_teams(repo, options=T.unsafe(nil)); end

  def repos(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def repositories(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def repository(repo, options=T.unsafe(nil)); end

  def repository?(repo, options=T.unsafe(nil)); end

  def repository_assignees(repo, options=T.unsafe(nil)); end

  def repository_teams(repo, options=T.unsafe(nil)); end

  def set_private(repo, options=T.unsafe(nil)); end

  def set_public(repo, options=T.unsafe(nil)); end

  def star(repo, options=T.unsafe(nil)); end

  def stargazers(repo, options=T.unsafe(nil)); end

  def subscribers(repo, options=T.unsafe(nil)); end

  def subscription(repo, options=T.unsafe(nil)); end

  def tags(repo, options=T.unsafe(nil)); end

  def teams(repo, options=T.unsafe(nil)); end

  def topics(repo, options=T.unsafe(nil)); end

  def transfer_repo(repo, new_owner, options=T.unsafe(nil)); end

  def transfer_repository(repo, new_owner, options=T.unsafe(nil)); end

  def unprotect_branch(repo, branch, options=T.unsafe(nil)); end

  def unstar(repo, options=T.unsafe(nil)); end

  def unwatch(repo, options=T.unsafe(nil)); end

  def update(repo, options=T.unsafe(nil)); end

  def update_deploy_key(repo, id, options); end

  def update_repository(repo, options=T.unsafe(nil)); end

  def update_subscription(repo, options=T.unsafe(nil)); end

  def watch(repo, options=T.unsafe(nil)); end

  def watchers(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Repositories
end

module Octokit::Client::RepositoryInvitations
  def accept_repo_invitation(invitation_id, options=T.unsafe(nil)); end

  def accept_repository_invitation(invitation_id, options=T.unsafe(nil)); end

  def decline_invitation(invitation_id, options=T.unsafe(nil)); end

  def decline_repository_invitation(invitation_id, options=T.unsafe(nil)); end

  def delete_repo_invitation(repo, invitation_id, options=T.unsafe(nil)); end

  def delete_repository_invitation(repo, invitation_id, options=T.unsafe(nil)); end

  def invite_user_to_repo(repo, user, options=T.unsafe(nil)); end

  def invite_user_to_repository(repo, user, options=T.unsafe(nil)); end

  def repo_invitations(repo, options=T.unsafe(nil)); end

  def repository_invitations(repo, options=T.unsafe(nil)); end

  def update_repo_invitation(repo, invitation_id, options=T.unsafe(nil)); end

  def update_repository_invitation(repo, invitation_id, options=T.unsafe(nil)); end

  def user_repo_invitations(options=T.unsafe(nil)); end

  def user_repository_invitations(options=T.unsafe(nil)); end
end

module Octokit::Client::RepositoryInvitations
end

module Octokit::Client::Reviews
  def create_pull_request_review(repo, number, options=T.unsafe(nil)); end

  def delete_pull_request_review(repo, number, review, options=T.unsafe(nil)); end

  def delete_pull_request_review_request(repo, id, reviewers=T.unsafe(nil), options=T.unsafe(nil)); end

  def dismiss_pull_request_review(repo, number, review, message, options=T.unsafe(nil)); end

  def pull_request_review(repo, number, review, options=T.unsafe(nil)); end

  def pull_request_review_comments(repo, number, review, options=T.unsafe(nil)); end

  def pull_request_review_requests(repo, number, options=T.unsafe(nil)); end

  def pull_request_reviews(repo, number, options=T.unsafe(nil)); end

  def request_pull_request_review(repo, number, reviewers=T.unsafe(nil), options=T.unsafe(nil)); end

  def submit_pull_request_review(repo, number, review, event, options=T.unsafe(nil)); end
end

module Octokit::Client::Reviews
end

module Octokit::Client::Say
  def octocat(text=T.unsafe(nil), options=T.unsafe(nil)); end

  def say(text=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Octokit::Client::Say
end

module Octokit::Client::Search
  def search_code(query, options=T.unsafe(nil)); end

  def search_commits(query, options=T.unsafe(nil)); end

  def search_issues(query, options=T.unsafe(nil)); end

  def search_repos(query, options=T.unsafe(nil)); end

  def search_repositories(query, options=T.unsafe(nil)); end

  def search_users(query, options=T.unsafe(nil)); end
end

module Octokit::Client::Search
end

module Octokit::Client::ServiceStatus
  def github_status(); end

  def github_status_last_message(); end

  def github_status_messages(); end
  STATUS_ROOT = ::T.let(nil, ::T.untyped)
end

module Octokit::Client::ServiceStatus
end

module Octokit::Client::SourceImport
  def cancel_source_import(repo, options=T.unsafe(nil)); end

  def map_source_import_commit_author(author_url, values, options=T.unsafe(nil)); end

  def set_source_import_lfs_preference(repo, use_lfs, options=T.unsafe(nil)); end

  def source_import_commit_authors(repo, options=T.unsafe(nil)); end

  def source_import_large_files(repo, options=T.unsafe(nil)); end

  def source_import_progress(repo, options=T.unsafe(nil)); end

  def start_source_import(*args); end

  def update_source_import(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::SourceImport
end

module Octokit::Client::Stats
  def code_frequency_stats(repo, options=T.unsafe(nil)); end

  def commit_activity_stats(repo, options=T.unsafe(nil)); end

  def contributor_stats(repo, options=T.unsafe(nil)); end

  def contributors_stats(repo, options=T.unsafe(nil)); end

  def participation_stats(repo, options=T.unsafe(nil)); end

  def punch_card(repo, options=T.unsafe(nil)); end

  def punch_card_stats(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Stats
end

module Octokit::Client::Statuses
  def combined_status(repo, ref, options=T.unsafe(nil)); end

  def create_status(repo, sha, state, options=T.unsafe(nil)); end

  def list_statuses(repo, sha, options=T.unsafe(nil)); end

  def status(repo, ref, options=T.unsafe(nil)); end

  def statuses(repo, sha, options=T.unsafe(nil)); end
end

module Octokit::Client::Statuses
end

module Octokit::Client::Traffic
  def clones(repo, options=T.unsafe(nil)); end

  def top_paths(repo, options=T.unsafe(nil)); end

  def top_referrers(repo, options=T.unsafe(nil)); end

  def views(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Traffic
end

module Octokit::Client::Users
  def add_email(email, options=T.unsafe(nil)); end

  def add_key(title, key, options=T.unsafe(nil)); end

  def all_users(options=T.unsafe(nil)); end

  def emails(options=T.unsafe(nil)); end

  def exchange_code_for_token(code, app_id=T.unsafe(nil), app_secret=T.unsafe(nil), options=T.unsafe(nil)); end

  def follow(user, options=T.unsafe(nil)); end

  def followers(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def following(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def follows?(*args); end

  def key(key_id, options=T.unsafe(nil)); end

  def keys(options=T.unsafe(nil)); end

  def remove_email(email); end

  def remove_key(id, options=T.unsafe(nil)); end

  def starred(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def starred?(repo, options=T.unsafe(nil)); end

  def subscriptions(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def unfollow(user, options=T.unsafe(nil)); end

  def update_key(key_id, options=T.unsafe(nil)); end

  def update_user(options); end

  def user(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def user_keys(user, options=T.unsafe(nil)); end

  def validate_credentials(options=T.unsafe(nil)); end

  def watched(user=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Octokit::Client::Users
end

class Octokit::Client
end

class Octokit::ClientError
end

class Octokit::ClientError
end

module Octokit::Configurable
  def access_token(); end

  def access_token=(access_token); end

  def api_endpoint(); end

  def api_endpoint=(api_endpoint); end

  def auto_paginate(); end

  def auto_paginate=(auto_paginate); end

  def bearer_token(); end

  def bearer_token=(bearer_token); end

  def client_id(); end

  def client_id=(client_id); end

  def client_secret(); end

  def client_secret=(client_secret); end

  def configure(); end

  def connection_options(); end

  def connection_options=(connection_options); end

  def default_media_type(); end

  def default_media_type=(default_media_type); end

  def login(); end

  def login=(login); end

  def management_console_endpoint(); end

  def management_console_endpoint=(management_console_endpoint); end

  def management_console_password=(management_console_password); end

  def middleware(); end

  def middleware=(middleware); end

  def netrc(); end

  def netrc=(netrc); end

  def netrc?(); end

  def netrc_file(); end

  def netrc_file=(netrc_file); end

  def password=(password); end

  def per_page(); end

  def per_page=(per_page); end

  def proxy(); end

  def proxy=(proxy); end

  def reset!(); end

  def same_options?(opts); end

  def setup(); end

  def ssl_verify_mode(); end

  def ssl_verify_mode=(ssl_verify_mode); end

  def user_agent(); end

  def user_agent=(user_agent); end

  def web_endpoint(); end

  def web_endpoint=(web_endpoint); end
end

module Octokit::Configurable
  def self.keys(); end
end

class Octokit::Conflict
end

class Octokit::Conflict
end

module Octokit::Connection
  include ::Octokit::Authentication
  def agent(); end

  def delete(url, options=T.unsafe(nil)); end

  def endpoint(); end

  def get(url, options=T.unsafe(nil)); end

  def head(url, options=T.unsafe(nil)); end

  def last_response(); end

  def paginate(url, options=T.unsafe(nil), &block); end

  def patch(url, options=T.unsafe(nil)); end

  def post(url, options=T.unsafe(nil)); end

  def put(url, options=T.unsafe(nil)); end

  def root(); end
  CONVENIENCE_HEADERS = ::T.let(nil, ::T.untyped)
end

module Octokit::Connection
end

module Octokit::Default
  API_ENDPOINT = ::T.let(nil, ::T.untyped)
  MEDIA_TYPE = ::T.let(nil, ::T.untyped)
  MIDDLEWARE = ::T.let(nil, ::T.untyped)
  USER_AGENT = ::T.let(nil, ::T.untyped)
  WEB_ENDPOINT = ::T.let(nil, ::T.untyped)
end

Octokit::Default::RACK_BUILDER_CLASS = Faraday::RackBuilder

module Octokit::Default
  def self.access_token(); end

  def self.api_endpoint(); end

  def self.auto_paginate(); end

  def self.bearer_token(); end

  def self.client_id(); end

  def self.client_secret(); end

  def self.connection_options(); end

  def self.default_media_type(); end

  def self.login(); end

  def self.management_console_endpoint(); end

  def self.management_console_password(); end

  def self.middleware(); end

  def self.netrc(); end

  def self.netrc_file(); end

  def self.options(); end

  def self.password(); end

  def self.per_page(); end

  def self.proxy(); end

  def self.ssl_verify_mode(); end

  def self.user_agent(); end

  def self.web_endpoint(); end
end

class Octokit::EnterpriseAdminClient
  include ::Octokit::Configurable
  include ::Octokit::Connection
  include ::Octokit::Authentication
  include ::Octokit::Warnable
  include ::Octokit::EnterpriseAdminClient::AdminStats
  include ::Octokit::EnterpriseAdminClient::License
  include ::Octokit::EnterpriseAdminClient::Orgs
  include ::Octokit::EnterpriseAdminClient::SearchIndexing
  include ::Octokit::EnterpriseAdminClient::Users
  def initialize(options=T.unsafe(nil)); end
end

module Octokit::EnterpriseAdminClient::AdminStats
  def admin_comments_stats(); end

  def admin_gists_stats(); end

  def admin_hooks_stats(); end

  def admin_issues_stats(); end

  def admin_milestones_stats(); end

  def admin_organization_stats(); end

  def admin_pages_stats(); end

  def admin_pull_requests_stats(); end

  def admin_repository_stats(); end

  def admin_stats(); end

  def admin_users_stats(); end
end

module Octokit::EnterpriseAdminClient::AdminStats
end

module Octokit::EnterpriseAdminClient::License
  def license_info(); end
end

module Octokit::EnterpriseAdminClient::License
end

module Octokit::EnterpriseAdminClient::Orgs
  def create_organization(login, admin, options=T.unsafe(nil)); end
end

module Octokit::EnterpriseAdminClient::Orgs
end

module Octokit::EnterpriseAdminClient::SearchIndexing
  def index_organization(user); end

  def index_organizations_repositories(user); end

  def index_organizations_repositories_code(user); end

  def index_organizations_repositories_issues(user); end

  def index_repository(repo); end

  def index_repository_code(repo); end

  def index_repository_issues(repo); end

  def index_user(user); end

  def index_users_repositories(user); end

  def index_users_repositories_code(user); end

  def index_users_repositories_issues(user); end
end

module Octokit::EnterpriseAdminClient::SearchIndexing
end

module Octokit::EnterpriseAdminClient::Users
  def create_impersonation_token(login, options=T.unsafe(nil)); end

  def create_user(login, email, options=T.unsafe(nil)); end

  def delete_impersonation_token(login, options=T.unsafe(nil)); end

  def delete_key(id, options=T.unsafe(nil)); end

  def delete_user(username, options=T.unsafe(nil)); end

  def demote(user, options=T.unsafe(nil)); end

  def list_all_keys(options=T.unsafe(nil)); end

  def promote(user, options=T.unsafe(nil)); end

  def rename_user(old_login, new_login, options=T.unsafe(nil)); end

  def suspend(user, options=T.unsafe(nil)); end

  def unsuspend(user, options=T.unsafe(nil)); end
end

module Octokit::EnterpriseAdminClient::Users
end

class Octokit::EnterpriseAdminClient
end

class Octokit::EnterpriseManagementConsoleClient
  include ::Octokit::Configurable
  include ::Octokit::Connection
  include ::Octokit::Authentication
  include ::Octokit::Warnable
  include ::Octokit::EnterpriseManagementConsoleClient::ManagementConsole
  def initialize(options=T.unsafe(nil)); end

  def management_console_endpoint=(value); end

  def management_console_password=(value); end
end

module Octokit::EnterpriseManagementConsoleClient::ManagementConsole
  def add_authorized_key(key); end

  def authorized_keys(); end

  def config_check(); end

  def config_status(); end

  def delete_authorized_key(key); end

  def edit_maintenance_status(maintenance); end

  def edit_settings(settings); end

  def get_authorized_keys(); end

  def get_maintenance_status(); end

  def get_settings(); end

  def maintenance_status(); end

  def remove_authorized_key(key); end

  def set_maintenance_status(maintenance); end

  def settings(); end

  def start_configuration(); end

  def upgrade(license); end

  def upload_license(license, settings=T.unsafe(nil)); end
end

module Octokit::EnterpriseManagementConsoleClient::ManagementConsole
end

class Octokit::EnterpriseManagementConsoleClient
end

class Octokit::Error
  def documentation_url(); end

  def errors(); end

  def initialize(response=T.unsafe(nil)); end

  def response_body(); end

  def response_headers(); end

  def response_status(); end
end

class Octokit::Error
  def self.error_for_401(headers); end

  def self.error_for_403(body); end

  def self.error_for_404(body); end

  def self.from_response(response); end
end

class Octokit::Forbidden
end

class Octokit::Forbidden
end

class Octokit::Gist
  def id(); end

  def id=(id); end

  def initialize(gist); end

  def url(); end
end

class Octokit::Gist
  def self.from_url(url); end
end

class Octokit::InternalServerError
end

class Octokit::InternalServerError
end

class Octokit::InvalidRepository
end

class Octokit::InvalidRepository
end

class Octokit::MethodNotAllowed
end

class Octokit::MethodNotAllowed
end

module Octokit::Middleware
end

class Octokit::Middleware::FollowRedirects
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  ENV_TO_CLEAR = ::T.let(nil, ::T.untyped)
  FOLLOW_LIMIT = ::T.let(nil, ::T.untyped)
  REDIRECT_CODES = ::T.let(nil, ::T.untyped)
  URI_UNSAFE = ::T.let(nil, ::T.untyped)
end

class Octokit::Middleware::FollowRedirects
end

class Octokit::Middleware::RedirectLimitReached
  def initialize(response); end
end

class Octokit::Middleware::RedirectLimitReached
end

module Octokit::Middleware
end

class Octokit::MissingContentType
end

class Octokit::MissingContentType
end

class Octokit::NotAcceptable
end

class Octokit::NotAcceptable
end

class Octokit::NotFound
end

class Octokit::NotFound
end

class Octokit::NotImplemented
end

class Octokit::NotImplemented
end

class Octokit::OneTimePasswordRequired
  def password_delivery(); end
  OTP_DELIVERY_PATTERN = ::T.let(nil, ::T.untyped)
end

class Octokit::OneTimePasswordRequired
  def self.required_header(headers); end
end

class Octokit::Organization
end

class Octokit::Organization
  def self.path(org); end
end

module Octokit::Preview
  def ensure_api_media_type(type, options); end

  def warn_preview(type); end
  PREVIEW_TYPES = ::T.let(nil, ::T.untyped)
end

module Octokit::Preview
end

class Octokit::RateLimit
end

class Octokit::RateLimit
  def self.from_response(response); end
end

class Octokit::RepoArguments
  def repo(); end
end

class Octokit::RepoArguments
end

class Octokit::Repository
  def id(); end

  def id=(id); end

  def id_api_path(); end

  def initialize(repo); end

  def name(); end

  def name=(name); end

  def named_api_path(); end

  def owner(); end

  def owner=(owner); end

  def path(); end

  def repo(); end

  def slug(); end

  def url(); end

  def user(); end

  def username(); end
  NAME_WITH_OWNER_PATTERN = ::T.let(nil, ::T.untyped)
end

class Octokit::Repository
  def self.from_url(url); end

  def self.path(repo); end
end

class Octokit::RepositoryUnavailable
end

class Octokit::RepositoryUnavailable
end

module Octokit::Response
end

class Octokit::Response::FeedParser
end

class Octokit::Response::FeedParser
end

class Octokit::Response::RaiseError
end

class Octokit::Response::RaiseError
end

module Octokit::Response
end

class Octokit::ServerError
end

class Octokit::ServerError
end

class Octokit::ServiceUnavailable
end

class Octokit::ServiceUnavailable
end

class Octokit::TooManyLoginAttempts
end

class Octokit::TooManyLoginAttempts
end

class Octokit::TooManyRequests
end

class Octokit::TooManyRequests
end

class Octokit::Unauthorized
end

class Octokit::Unauthorized
end

class Octokit::UnavailableForLegalReasons
end

class Octokit::UnavailableForLegalReasons
end

class Octokit::UnprocessableEntity
end

class Octokit::UnprocessableEntity
end

class Octokit::UnsupportedMediaType
end

class Octokit::UnsupportedMediaType
end

class Octokit::UnverifiedEmail
end

class Octokit::UnverifiedEmail
end

class Octokit::User
end

class Octokit::User
  def self.path(user); end
end

module Octokit::Warnable
  def octokit_warn(*message); end
end

module Octokit::Warnable
end

module Octokit
  extend ::Octokit::Configurable
  def self.client(); end

  def self.enterprise_admin_client(); end

  def self.enterprise_management_console_client(); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

class OpenSSL::PKey::RSA
  def sign_pss(*_); end

  def verify_pss(*_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def add_certificate(*_); end

  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

module Parts
end

class Parts::EpiloguePart
  include ::Parts::Part
  def initialize(boundary); end
end

class Parts::EpiloguePart
end

class Parts::FilePart
  include ::Parts::Part
  def build_head(boundary, name, filename, type, content_len, opts=T.unsafe(nil)); end

  def initialize(boundary, name, io, headers=T.unsafe(nil)); end
end

class Parts::FilePart
end

class Parts::ParamPart
  include ::Parts::Part
  def build_part(boundary, name, value, headers=T.unsafe(nil)); end

  def initialize(boundary, name, value, headers=T.unsafe(nil)); end
end

class Parts::ParamPart
end

module Parts::Part
  def length(); end

  def to_io(); end
end

module Parts::Part
  def self.file?(value); end

  def self.new(boundary, name, value, headers=T.unsafe(nil)); end
end

module Parts
end

class Pathname
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def ===(*_); end

  def clone(); end

  def yield(*_); end
end

module Process::Sys
  def self.getegid(); end
end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  def self.[](*_); end

  def self.members(); end
end

module Process
  def self.last_status(); end

  def self.setpgrp(); end
end

module PublicSuffix
  BANG = ::T.let(nil, ::T.untyped)
  DOT = ::T.let(nil, ::T.untyped)
  STAR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::Domain
  def domain(); end

  def domain?(); end

  def initialize(*args); end

  def name(); end

  def sld(); end

  def subdomain(); end

  def subdomain?(); end

  def tld(); end

  def to_a(); end

  def trd(); end
end

class PublicSuffix::Domain
  def self.name_to_labels(name); end
end

class PublicSuffix::DomainInvalid
end

class PublicSuffix::DomainInvalid
end

class PublicSuffix::DomainNotAllowed
end

class PublicSuffix::DomainNotAllowed
end

class PublicSuffix::Error
end

class PublicSuffix::Error
end

class PublicSuffix::List
  def <<(rule); end

  def ==(other); end

  def add(rule); end

  def clear(); end

  def default_rule(); end

  def each(&block); end

  def empty?(); end

  def eql?(other); end

  def find(name, default: T.unsafe(nil), **options); end

  def rules(); end

  def size(); end
  DEFAULT_LIST_PATH = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::List
  def self.default(**options); end

  def self.default=(value); end

  def self.parse(input, private_domains: T.unsafe(nil)); end
end

module PublicSuffix::Rule
end

class PublicSuffix::Rule::Base
  def ==(other); end

  def decompose(*_); end

  def eql?(other); end

  def initialize(value:, length: T.unsafe(nil), private: T.unsafe(nil)); end

  def length(); end

  def match?(name); end

  def parts(); end

  def private(); end

  def value(); end
end

class PublicSuffix::Rule::Base
  def self.build(content, private: T.unsafe(nil)); end
end

class PublicSuffix::Rule::Entry
  def length=(_); end

  def private(); end

  def private=(_); end

  def type(); end

  def type=(_); end
end

class PublicSuffix::Rule::Entry
  def self.[](*_); end

  def self.members(); end
end

class PublicSuffix::Rule::Exception
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Exception
end

class PublicSuffix::Rule::Normal
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Normal
end

class PublicSuffix::Rule::Wildcard
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Wildcard
end

module PublicSuffix::Rule
  def self.default(); end

  def self.factory(content, private: T.unsafe(nil)); end
end

module PublicSuffix
  def self.decompose(name, rule); end

  def self.domain(name, **options); end

  def self.normalize(name); end

  def self.parse(name, list: T.unsafe(nil), default_rule: T.unsafe(nil), ignore_private: T.unsafe(nil)); end

  def self.valid?(name, list: T.unsafe(nil), default_rule: T.unsafe(nil), ignore_private: T.unsafe(nil)); end
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_HIJACK_IO = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_MULTIPROCESS = ::T.let(nil, ::T.untyped)
  RACK_MULTITHREAD = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RUNONCE = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_ADDR = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Rack::Auth
end

class Rack::Auth::AbstractHandler
  def initialize(app, realm=T.unsafe(nil), &authenticator); end

  def realm(); end

  def realm=(realm); end
end

class Rack::Auth::AbstractHandler
end

class Rack::Auth::AbstractRequest
  def initialize(env); end

  def params(); end

  def parts(); end

  def provided?(); end

  def request(); end

  def scheme(); end

  def valid?(); end
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
end

class Rack::Auth::Basic
  def call(env); end
end

class Rack::Auth::Basic::Request
  def basic?(); end

  def credentials(); end

  def username(); end
end

class Rack::Auth::Basic::Request
end

class Rack::Auth::Basic
end

module Rack::Auth::Digest
end

class Rack::Auth::Digest::MD5
  def call(env); end

  def initialize(app, realm=T.unsafe(nil), opaque=T.unsafe(nil), &authenticator); end

  def opaque(); end

  def opaque=(opaque); end

  def passwords_hashed=(passwords_hashed); end

  def passwords_hashed?(); end
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
end

class Rack::Auth::Digest::Nonce
  def digest(); end

  def fresh?(); end

  def initialize(timestamp=T.unsafe(nil), given_digest=T.unsafe(nil)); end

  def stale?(); end

  def valid?(); end
end

class Rack::Auth::Digest::Nonce
  def self.parse(string); end

  def self.private_key(); end

  def self.private_key=(private_key); end

  def self.time_limit(); end

  def self.time_limit=(time_limit); end
end

class Rack::Auth::Digest::Params
  def [](k); end

  def []=(k, v); end

  def initialize(); end

  def quote(str); end
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  def self.dequote(str); end

  def self.parse(str); end

  def self.split_header_value(str); end
end

class Rack::Auth::Digest::Request
  def correct_uri?(); end

  def digest?(); end

  def method(); end

  def method_missing(sym, *args); end

  def nonce(); end

  def respond_to?(sym, *_); end
end

class Rack::Auth::Digest::Request
end

module Rack::Auth::Digest
end

module Rack::Auth
end

class Rack::BodyProxy
  def close(); end

  def closed?(); end

  def each(&blk); end

  def initialize(body, &block); end

  def method_missing(method_name, *args, &block); end

  def respond_to?(method_name, include_all=T.unsafe(nil)); end
end

class Rack::BodyProxy
end

class Rack::Builder
  include ::Sinatra::Delegator
  def call(env); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
end

class Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Rack::Cascade
  def <<(app); end

  def add(app); end

  def apps(); end

  def call(env); end

  def include?(app); end

  def initialize(apps, catch=T.unsafe(nil)); end
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
end

class Rack::Chunked
  include ::Rack::Utils
  def call(env); end

  def chunkable_version?(ver); end

  def initialize(app); end
end

class Rack::Chunked::Body
  include ::Rack::Utils
  def close(); end

  def each(&blk); end

  def initialize(body); end
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::Chunked::Body
end

class Rack::Chunked
end

class Rack::CommonLogger
  def call(env); end

  def call_without_check(env); end

  def initialize(app, logger=T.unsafe(nil)); end
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
end

class Rack::ConditionalGet
  def call(env); end

  def initialize(app); end
end

class Rack::ConditionalGet
end

class Rack::Config
  def call(env); end

  def initialize(app, &block); end
end

class Rack::Config
end

class Rack::ContentLength
  include ::Rack::Utils
  def call(env); end

  def initialize(app); end
end

class Rack::ContentLength
end

class Rack::ContentType
  include ::Rack::Utils
  def call(env); end

  def initialize(app, content_type=T.unsafe(nil)); end
end

class Rack::ContentType
end

class Rack::Deflater
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Rack::Deflater::GzipStream
  def close(); end

  def each(&block); end

  def initialize(body, mtime); end

  def write(data); end
end

class Rack::Deflater::GzipStream
end

class Rack::Deflater
end

class Rack::Directory
  def call(env); end

  def check_bad_request(path_info); end

  def check_forbidden(path_info); end

  def entity_not_found(path_info); end

  def filesize_format(int); end

  def get(env); end

  def initialize(root, app=T.unsafe(nil)); end

  def list_directory(path_info, path, script_name); end

  def list_path(env, path, path_info, script_name); end

  def path(); end

  def root(); end

  def stat(node); end
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory
end

class Rack::ETag
  def call(env); end

  def initialize(app, no_cache_control=T.unsafe(nil), cache_control=T.unsafe(nil)); end
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

class Rack::ETag
end

class Rack::File
  def call(env); end

  def get(env); end

  def initialize(root, headers=T.unsafe(nil), default_mime=T.unsafe(nil)); end

  def root(); end

  def serving(request, path); end
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
end

class Rack::File::Iterator
  def close(); end

  def each(&blk); end

  def initialize(path, range); end

  def path(); end

  def range(); end

  def to_path(); end
end

class Rack::File::Iterator
end

class Rack::File
end

class Rack::ForwardRequest
  def env(); end

  def initialize(url, env=T.unsafe(nil)); end

  def url(); end
end

class Rack::ForwardRequest
end

module Rack::Handler
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, options=T.unsafe(nil)); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rack::Handler::WEBrick
  def initialize(server, app); end
end

class Rack::Handler::WEBrick
  def self.run(app, options=T.unsafe(nil)); end

  def self.shutdown(); end

  def self.valid_options(); end
end

module Rack::Handler
  def self.default(); end

  def self.get(server); end

  def self.pick(server_names); end

  def self.register(server, klass); end

  def self.try_require(prefix, const_name); end
end

class Rack::Head
  def call(env); end

  def initialize(app); end
end

class Rack::Head
end

class Rack::Lint
  include ::Rack::Lint::Assertion
  def _call(env); end

  def call(env=T.unsafe(nil)); end

  def check_content_length(status, headers); end

  def check_content_type(status, headers); end

  def check_env(env); end

  def check_error(error); end

  def check_headers(header); end

  def check_hijack(env); end

  def check_hijack_response(headers, env); end

  def check_input(input); end

  def check_status(status); end

  def close(); end

  def each(&blk); end

  def initialize(app); end

  def verify_content_length(bytes); end
end

module Rack::Lint::Assertion
  def assert(message); end
end

module Rack::Lint::Assertion
end

class Rack::Lint::ErrorWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def flush(); end

  def initialize(error); end

  def puts(str); end

  def write(str); end
end

class Rack::Lint::ErrorWrapper
end

class Rack::Lint::HijackWrapper
  include ::Rack::Lint::Assertion
  def close(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def flush(*args, &block); end

  def initialize(io); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::Lint::HijackWrapper
  extend ::Forwardable
end

class Rack::Lint::InputWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def each(*args, &blk); end

  def gets(*args); end

  def initialize(input); end

  def read(*args); end

  def rewind(*args); end
end

class Rack::Lint::InputWrapper
end

class Rack::Lint::LintError
end

class Rack::Lint::LintError
end

class Rack::Lint
end

class Rack::Lock
  def call(env); end

  def initialize(app, mutex=T.unsafe(nil)); end
end

class Rack::Lock
end

class Rack::Logger
  def call(env); end

  def initialize(app, level=T.unsafe(nil)); end
end

class Rack::Logger
end

class Rack::MediaType
  SPLIT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rack::MediaType
  def self.params(content_type); end

  def self.type(content_type); end
end

class Rack::MethodOverride
  def call(env); end

  def initialize(app); end

  def method_override(env); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  def self.match?(value, matcher); end

  def self.mime_type(ext, fallback=T.unsafe(nil)); end
end

class Rack::MockRequest
  def delete(uri, opts=T.unsafe(nil)); end

  def get(uri, opts=T.unsafe(nil)); end

  def head(uri, opts=T.unsafe(nil)); end

  def initialize(app); end

  def options(uri, opts=T.unsafe(nil)); end

  def patch(uri, opts=T.unsafe(nil)); end

  def post(uri, opts=T.unsafe(nil)); end

  def put(uri, opts=T.unsafe(nil)); end

  def request(method=T.unsafe(nil), uri=T.unsafe(nil), opts=T.unsafe(nil)); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest::FatalWarner
  def flush(); end

  def puts(warning); end

  def string(); end

  def write(warning); end
end

class Rack::MockRequest::FatalWarner
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest
  def self.env_for(uri=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.parse_uri_rfc2396(uri); end
end

class Rack::MockResponse
  def =~(other); end

  def errors(); end

  def errors=(errors); end

  def initialize(status, headers, body, errors=T.unsafe(nil)); end

  def match(other); end

  def original_headers(); end
end

class Rack::MockResponse
end

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN_QUOTED = ::T.let(nil, ::T.untyped)
  BROKEN_UNQUOTED = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Generator
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::Parser
  def initialize(boundary, tempfile, bufsize, query_parser); end

  def on_read(content); end

  def result(); end

  def state(); end
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Parser::BoundedIO
  def initialize(io, content_length); end

  def read(size); end

  def rewind(); end
end

class Rack::Multipart::Parser::BoundedIO
end

class Rack::Multipart::Parser::Collector
  include ::Enumerable
  def each(&blk); end

  def initialize(tempfile); end

  def on_mime_body(mime_index, content); end

  def on_mime_finish(mime_index); end

  def on_mime_head(mime_index, head, filename, content_type, name); end
end

class Rack::Multipart::Parser::Collector::BufferPart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::BufferPart
end

class Rack::Multipart::Parser::Collector::MimePart
  def get_data(); end
end

class Rack::Multipart::Parser::Collector::MimePart
end

class Rack::Multipart::Parser::Collector::TempfilePart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::TempfilePart
end

class Rack::Multipart::Parser::Collector
end

class Rack::Multipart::Parser::MultipartInfo
  def params(); end

  def params=(_); end

  def tmp_files(); end

  def tmp_files=(_); end
end

class Rack::Multipart::Parser::MultipartInfo
  def self.[](*_); end

  def self.members(); end
end

class Rack::Multipart::Parser
  def self.parse(io, content_length, content_type, tmpfile, bufsize, qp); end

  def self.parse_boundary(content_type); end
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(path, content_type=T.unsafe(nil), binary=T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

class Rack::Multipart::UploadedFile
end

module Rack::Multipart
  def self.build_multipart(params, first=T.unsafe(nil)); end

  def self.extract_multipart(req, params=T.unsafe(nil)); end

  def self.parse_multipart(env, params=T.unsafe(nil)); end
end

class Rack::NullLogger
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def call(env); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(datetime_format); end

  def debug(progname=T.unsafe(nil), &block); end

  def debug?(); end

  def error(progname=T.unsafe(nil), &block); end

  def error?(); end

  def fatal(progname=T.unsafe(nil), &block); end

  def fatal?(); end

  def formatter(); end

  def formatter=(formatter); end

  def info(progname=T.unsafe(nil), &block); end

  def info?(); end

  def initialize(app); end

  def level(); end

  def level=(level); end

  def progname(); end

  def progname=(progname); end

  def sev_threshold(); end

  def sev_threshold=(sev_threshold); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end

  def warn?(); end
end

class Rack::NullLogger
end

module Rack::Protection
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::AuthenticityToken
  def mask_authenticity_token(session); end
  TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::AuthenticityToken
  def self.random_token(); end

  def self.token(session); end
end

class Rack::Protection::Base
  def accepts?(env); end

  def app(); end

  def call(env); end

  def default_options(); end

  def default_reaction(env); end

  def deny(env); end

  def drop_session(env); end

  def encrypt(value); end

  def html?(headers); end

  def initialize(app, options=T.unsafe(nil)); end

  def instrument(env); end

  def options(); end

  def origin(env); end

  def random_string(secure=T.unsafe(nil)); end

  def react(env); end

  def referrer(env); end

  def report(env); end

  def safe?(env); end

  def secure_compare(a, b); end

  def session(env); end

  def session?(env); end

  def warn(env, message); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::Base
  def self.default_options(options); end

  def self.default_reaction(reaction); end
end

class Rack::Protection::ContentSecurityPolicy
  def csp_policy(); end
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  NO_ARG_DIRECTIVES = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::ContentSecurityPolicy
end

class Rack::Protection::CookieTossing
  def bad_cookies(); end

  def cookie_paths(path); end

  def empty_cookie(host, path); end

  def redirect(env); end

  def remove_bad_cookies(request, response); end

  def session_key(); end
end

class Rack::Protection::CookieTossing
end

class Rack::Protection::EscapedParams
  def escape(object); end

  def escape_hash(hash); end

  def escape_string(str); end

  def handle(hash); end

  def initialize(*_); end
end

class Rack::Protection::EscapedParams
  extend ::Rack::Utils
end

class Rack::Protection::FormToken
end

class Rack::Protection::FormToken
end

class Rack::Protection::FrameOptions
  def frame_options(); end
end

class Rack::Protection::FrameOptions
end

class Rack::Protection::HttpOrigin
  def base_url(env); end
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::HttpOrigin
end

class Rack::Protection::IPSpoofing
end

class Rack::Protection::IPSpoofing
end

class Rack::Protection::JsonCsrf
  def close_body(body); end

  def has_vector?(request, headers); end

  def react_and_close(env, body); end
end

class Rack::Protection::JsonCsrf
end

class Rack::Protection::PathTraversal
  def cleanup(path); end
end

class Rack::Protection::PathTraversal
end

class Rack::Protection::RemoteReferrer
end

class Rack::Protection::RemoteReferrer
end

class Rack::Protection::RemoteToken
end

class Rack::Protection::RemoteToken
end

class Rack::Protection::SessionHijacking
end

class Rack::Protection::SessionHijacking
end

class Rack::Protection::StrictTransport
  def strict_transport(); end
end

class Rack::Protection::StrictTransport
end

class Rack::Protection::XSSHeader
end

class Rack::Protection::XSSHeader
end

module Rack::Protection
  def self.new(app, options=T.unsafe(nil)); end
end

class Rack::QueryParser
  def initialize(params_class, key_space_limit, param_depth_limit); end

  def key_space_limit(); end

  def make_params(); end

  def new_depth_limit(param_depth_limit); end

  def new_space_limit(key_space_limit); end

  def normalize_params(params, name, v, depth); end

  def param_depth_limit(); end

  def parse_nested_query(qs, d=T.unsafe(nil)); end

  def parse_query(qs, d=T.unsafe(nil), &unescaper); end
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::QueryParser::InvalidParameterError
end

class Rack::QueryParser::InvalidParameterError
end

class Rack::QueryParser::ParameterTypeError
end

class Rack::QueryParser::ParameterTypeError
end

class Rack::QueryParser::Params
  def [](key); end

  def []=(key, value); end

  def initialize(limit); end

  def key?(key); end

  def to_params_hash(); end
end

class Rack::QueryParser::Params
end

class Rack::QueryParser
  def self.make_default(key_space_limit, param_depth_limit); end
end

class Rack::Recursive
  def _call(env); end

  def call(env); end

  def include(env, path); end

  def initialize(app); end
end

class Rack::Recursive
end

class Rack::Reloader
  def call(env); end

  def initialize(app, cooldown=T.unsafe(nil), backend=T.unsafe(nil)); end

  def reload!(stderr=T.unsafe(nil)); end

  def safe_load(file, mtime, stderr=T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  def figure_path(file, paths); end

  def rotation(); end

  def safe_stat(file); end
end

module Rack::Reloader::Stat
end

class Rack::Reloader
end

class Rack::Request
  include ::Rack::Request::Env
  include ::Rack::Request::Helpers
  SCHEME_WHITELIST = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Env
  def add_header(key, v); end

  def delete_header(name); end

  def each_header(&block); end

  def env(); end

  def fetch_header(name, &block); end

  def get_header(name); end

  def has_header?(name); end

  def initialize(env); end

  def set_header(name, v); end
end

module Rack::Request::Env
end

module Rack::Request::Helpers
  def GET(); end

  def POST(); end

  def [](key); end

  def []=(key, value); end

  def accept_encoding(); end

  def accept_language(); end

  def authority(); end

  def base_url(); end

  def body(); end

  def content_charset(); end

  def content_length(); end

  def content_type(); end

  def cookies(); end

  def delete?(); end

  def delete_param(k); end

  def form_data?(); end

  def fullpath(); end

  def get?(); end

  def head?(); end

  def host(); end

  def host_with_port(); end

  def ip(); end

  def link?(); end

  def logger(); end

  def media_type(); end

  def media_type_params(); end

  def multithread?(); end

  def options?(); end

  def params(); end

  def parseable_data?(); end

  def patch?(); end

  def path(); end

  def path_info(); end

  def path_info=(s); end

  def port(); end

  def post?(); end

  def put?(); end

  def query_string(); end

  def referer(); end

  def referrer(); end

  def request_method(); end

  def scheme(); end

  def script_name(); end

  def script_name=(s); end

  def session(); end

  def session_options(); end

  def ssl?(); end

  def trace?(); end

  def trusted_proxy?(ip); end

  def unlink?(); end

  def update_param(k, v); end

  def url(); end

  def user_agent(); end

  def values_at(*keys); end

  def xhr?(); end
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_HOST = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PORT = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Helpers
end

class Rack::Request
end

class Rack::Response
  include ::Rack::Response::Helpers
  def [](key); end

  def []=(key, v); end

  def body(); end

  def body=(body); end

  def chunked?(); end

  def close(); end

  def delete_header(key); end

  def each(&callback); end

  def empty?(); end

  def finish(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(body=T.unsafe(nil), status=T.unsafe(nil), header=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def redirect(target, status=T.unsafe(nil)); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def to_a(&block); end

  def to_ary(&block); end

  def write(str); end
  CHUNKED = ::T.let(nil, ::T.untyped)
end

module Rack::Response::Helpers
  def accepted?(); end

  def add_header(key, v); end

  def bad_request?(); end

  def cache_control(); end

  def cache_control=(v); end

  def client_error?(); end

  def content_length(); end

  def content_type(); end

  def created?(); end

  def delete_cookie(key, value=T.unsafe(nil)); end

  def etag(); end

  def etag=(v); end

  def forbidden?(); end

  def include?(header); end

  def informational?(); end

  def invalid?(); end

  def location(); end

  def location=(location); end

  def media_type(); end

  def media_type_params(); end

  def method_not_allowed?(); end

  def moved_permanently?(); end

  def no_content?(); end

  def not_found?(); end

  def ok?(); end

  def precondition_failed?(); end

  def redirect?(); end

  def redirection?(); end

  def server_error?(); end

  def set_cookie(key, value); end

  def set_cookie_header(); end

  def set_cookie_header=(v); end

  def successful?(); end

  def unauthorized?(); end

  def unprocessable?(); end
end

module Rack::Response::Helpers
end

class Rack::Response::Raw
  include ::Rack::Response::Helpers
  def delete_header(key); end

  def get_header(key); end

  def has_header?(key); end

  def headers(); end

  def initialize(status, headers); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end
end

class Rack::Response::Raw
end

class Rack::Response
end

class Rack::Runtime
  def call(env); end

  def initialize(app, name=T.unsafe(nil)); end
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
  HEADER_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::Runtime
end

class Rack::Sendfile
  def call(env); end

  def initialize(app, variation=T.unsafe(nil), mappings=T.unsafe(nil)); end
end

class Rack::Sendfile
end

class Rack::Server
  def app(); end

  def default_options(); end

  def initialize(options=T.unsafe(nil)); end

  def middleware(); end

  def options(); end

  def options=(options); end

  def server(); end

  def start(&blk); end
end

class Rack::Server::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Rack::Server::Options
end

class Rack::Server
  def self.default_middleware_by_environment(); end

  def self.logging_middleware(); end

  def self.middleware(); end

  def self.start(options=T.unsafe(nil)); end
end

module Rack::Session
end

module Rack::Session::Abstract
end

class Rack::Session::Abstract::ID
  def find_session(req, sid); end
end

class Rack::Session::Abstract::ID
  def self.inherited(klass); end
end

class Rack::Session::Abstract::Persisted
  def call(env); end

  def commit_session(req, res); end

  def context(env, app=T.unsafe(nil)); end

  def default_options(); end

  def initialize(app, options=T.unsafe(nil)); end

  def key(); end

  def sid_secure(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::Persisted
end

class Rack::Session::Abstract::SessionHash
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def destroy(); end

  def each(&block); end

  def empty?(); end

  def exists?(); end

  def fetch(key, default=T.unsafe(nil), &block); end

  def has_key?(key); end

  def id(); end

  def id=(id); end

  def include?(key); end

  def initialize(store, req); end

  def key?(key); end

  def keys(); end

  def loaded?(); end

  def merge!(hash); end

  def options(); end

  def replace(hash); end

  def store(key, value); end

  def to_hash(); end

  def update(hash); end

  def values(); end
  Unspecified = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::SessionHash
  def self.find(req); end

  def self.set(req, session); end

  def self.set_options(req, options); end
end

module Rack::Session::Abstract
end

class Rack::Session::Cookie
  def coder(); end
end

class Rack::Session::Cookie::Base64
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::JSON
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::ZipJSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::ZipJSON
end

class Rack::Session::Cookie::Base64
end

class Rack::Session::Cookie::Identity
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Identity
end

class Rack::Session::Cookie
end

class Rack::Session::Pool
  def delete_session(req, session_id, options); end

  def find_session(req, sid); end

  def generate_sid(); end

  def mutex(); end

  def pool(); end

  def with_lock(req); end

  def write_session(req, session_id, new_session, options); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
end

module Rack::Session
end

class Rack::ShowExceptions
  def call(env); end

  def dump_exception(exception); end

  def h(obj); end

  def initialize(app); end

  def prefers_plaintext?(env); end

  def pretty(env, exception); end
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
end

class Rack::ShowStatus
  def call(env); end

  def h(obj); end

  def initialize(app); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
end

class Rack::Static
  def add_index_root?(path); end

  def applicable_rules(path); end

  def call(env); end

  def can_serve(path); end

  def initialize(app, options=T.unsafe(nil)); end

  def overwrite_file_path(path); end

  def route_file(path); end
end

class Rack::Static
end

class Rack::TempfileReaper
  def call(env); end

  def initialize(app); end
end

class Rack::TempfileReaper
end

class Rack::URLMap
  def call(env); end

  def initialize(map=T.unsafe(nil)); end

  def remap(map); end
  INFINITY = ::T.let(nil, ::T.untyped)
  NEGATIVE_INFINITY = ::T.let(nil, ::T.untyped)
end

class Rack::URLMap
end

module Rack::Utils
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  NULL_BYTE = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

module Rack::Utils
  def self.add_cookie_to_header(header, key, value); end

  def self.add_remove_cookie_to_header(header, key, value=T.unsafe(nil)); end

  def self.best_q_match(q_value_header, available_mimes); end

  def self.build_nested_query(value, prefix=T.unsafe(nil)); end

  def self.build_query(params); end

  def self.byte_ranges(env, size); end

  def self.clean_path_info(path_info); end

  def self.clock_time(); end

  def self.default_query_parser(); end

  def self.default_query_parser=(default_query_parser); end

  def self.delete_cookie_header!(header, key, value=T.unsafe(nil)); end

  def self.escape(s); end

  def self.escape_html(string); end

  def self.escape_path(s); end

  def self.get_byte_ranges(http_range, size); end

  def self.key_space_limit(); end

  def self.key_space_limit=(v); end

  def self.make_delete_cookie_header(header, key, value); end

  def self.multipart_part_limit(); end

  def self.multipart_part_limit=(multipart_part_limit); end

  def self.param_depth_limit(); end

  def self.param_depth_limit=(v); end

  def self.parse_cookies(env); end

  def self.parse_cookies_header(header); end

  def self.parse_nested_query(qs, d=T.unsafe(nil)); end

  def self.parse_query(qs, d=T.unsafe(nil), &unescaper); end

  def self.q_values(q_value_header); end

  def self.rfc2109(time); end

  def self.rfc2822(time); end

  def self.secure_compare(a, b); end

  def self.select_best_encoding(available_encodings, accept_encoding); end

  def self.set_cookie_header!(header, key, value); end

  def self.status_code(status); end

  def self.unescape(s, encoding=T.unsafe(nil)); end

  def self.unescape_path(s); end

  def self.valid_path?(path); end
end

module Rack
  def self.release(); end

  def self.version(); end
end

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end
  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

class Random
  def self.urandom(_); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.ruby(); end
end

class Regexp
  def match?(*_); end
end

class Regexp
  def self.union(*_); end
end

class RubyVM::InstructionSequence
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

class RubyVM
  def self.stat(*_); end
end

module Sawyer
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sawyer::Agent
  def allow_undefined_methods(); end

  def allow_undefined_methods=(allow_undefined_methods); end

  def allow_undefined_methods?(); end

  def call(method, url, data=T.unsafe(nil), options=T.unsafe(nil)); end

  def decode_body(str); end

  def encode_body(data); end

  def expand_url(url, options=T.unsafe(nil)); end

  def initialize(endpoint, options=T.unsafe(nil)); end

  def links_parser(); end

  def links_parser=(links_parser); end

  def marshal_dump(); end

  def marshal_load(dumped); end

  def parse_links(data); end

  def rels(); end

  def root(); end

  def start(); end

  def to_yaml_properties(); end
  NO_BODY = ::T.let(nil, ::T.untyped)
end

class Sawyer::Agent
  def self.decode(data); end

  def self.encode(data); end

  def self.serializer(); end

  def self.serializer=(serializer); end
end

class Sawyer::Error
end

class Sawyer::Error
end

module Sawyer::LinkParsers
end

class Sawyer::LinkParsers::Hal
  def parse(data); end
end

class Sawyer::LinkParsers::Hal
end

class Sawyer::LinkParsers::Simple
  def parse(data); end
  LINK_REGEX = ::T.let(nil, ::T.untyped)
end

class Sawyer::LinkParsers::Simple
end

module Sawyer::LinkParsers
end

class Sawyer::Relation
  def agent(); end

  def available_methods(); end

  def call(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def get(options=T.unsafe(nil)); end

  def head(options=T.unsafe(nil)); end

  def href_template(); end

  def initialize(agent, name, href, method=T.unsafe(nil)); end

  def method(); end

  def name(); end

  def options(data=T.unsafe(nil), opt=T.unsafe(nil)); end

  def patch(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def post(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def put(data=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Sawyer::Relation::Map
  def <<(rel); end

  def [](key); end

  def keys(); end

  def size(); end

  def to_h(); end

  def to_hash(); end
end

class Sawyer::Relation::Map
end

class Sawyer::Relation
  def self.from_link(agent, name, options); end

  def self.from_links(agent, index, rels=T.unsafe(nil)); end
end

class Sawyer::Resource
  include ::Enumerable
  def [](method); end

  def []=(method, value); end

  def _agent(); end

  def _fields(); end

  def _rels(); end

  def attrs(); end

  def each(&block); end

  def initialize(agent, data=T.unsafe(nil)); end

  def key?(key); end

  def marshal_dump(); end

  def marshal_load(dumped); end

  def method_missing(method, *args); end

  def process_value(value); end

  def to_attrs(); end

  def to_h(); end

  def to_hash(); end

  def to_yaml_properties(); end
  ATTR_PREDICATE = ::T.let(nil, ::T.untyped)
  ATTR_SETTER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHODS = ::T.let(nil, ::T.untyped)
end

class Sawyer::Resource
  def self.attr_accessor(*attrs); end
end

class Sawyer::Response
  def agent(); end

  def body(); end

  def data(); end

  def env(); end

  def headers(); end

  def initialize(agent, res, options=T.unsafe(nil)); end

  def process_data(data); end

  def process_rels(); end

  def rels(); end

  def status(); end

  def time(); end

  def timing(); end
end

class Sawyer::Response
end

class Sawyer::Serializer
  def decode(data); end

  def decode_hash(hash); end

  def decode_hash_value(key, value); end

  def decode_object(data); end

  def dump(data); end

  def encode(data); end

  def encode_hash(hash); end

  def encode_object(data); end

  def initialize(format, dump_method_name=T.unsafe(nil), load_method_name=T.unsafe(nil)); end

  def load(data); end

  def time_field?(key, value); end
end

class Sawyer::Serializer
  def self.any_json(); end

  def self.json(); end

  def self.message_pack(); end

  def self.multi_json(); end

  def self.yajl(); end
end

module Sawyer
end

ScanError = StringScanner::Error

module SecureRandom
end

module SecureRandom
  extend ::Random::Formatter
  def self.bytes(n); end
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class SignalException
  def signm(); end

  def signo(); end
end

module Sinatra
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sinatra::Application
end

class Sinatra::Application
end

class Sinatra::BadRequest
  def http_status(); end
end

class Sinatra::BadRequest
end

class Sinatra::Base
  include ::Rack::Utils
  include ::Sinatra::Helpers
  include ::Sinatra::Templates
  def app(); end

  def app=(app); end

  def call(env); end

  def call!(env); end

  def env(); end

  def env=(env); end

  def forward(); end

  def halt(*response); end

  def initialize(app=T.unsafe(nil)); end

  def options(); end

  def params(); end

  def params=(params); end

  def pass(&block); end

  def request(); end

  def request=(request); end

  def response(); end

  def response=(response); end

  def settings(); end

  def template_cache(); end
  URI_INSTANCE = ::T.let(nil, ::T.untyped)
end

class Sinatra::Base
  def self.absolute_redirects(); end

  def self.absolute_redirects=(val); end

  def self.absolute_redirects?(); end

  def self.add_charset(); end

  def self.add_charset=(val); end

  def self.add_charset?(); end

  def self.add_filter(type, path=T.unsafe(nil), **options, &block); end

  def self.after(path=T.unsafe(nil), **options, &block); end

  def self.app_file(); end

  def self.app_file=(val); end

  def self.app_file?(); end

  def self.before(path=T.unsafe(nil), **options, &block); end

  def self.bind(); end

  def self.bind=(val); end

  def self.bind?(); end

  def self.build(app); end

  def self.call(env); end

  def self.caller_files(); end

  def self.caller_locations(); end

  def self.condition(name=T.unsafe(nil), &block); end

  def self.configure(*envs); end

  def self.default_encoding(); end

  def self.default_encoding=(val); end

  def self.default_encoding?(); end

  def self.delete(path, opts=T.unsafe(nil), &bk); end

  def self.development?(); end

  def self.disable(*opts); end

  def self.dump_errors(); end

  def self.dump_errors=(val); end

  def self.dump_errors?(); end

  def self.empty_path_info(); end

  def self.empty_path_info=(val); end

  def self.empty_path_info?(); end

  def self.enable(*opts); end

  def self.environment(); end

  def self.environment=(val); end

  def self.environment?(); end

  def self.error(*codes, &block); end

  def self.errors(); end

  def self.extensions(); end

  def self.filters(); end

  def self.force_encoding(data, encoding=T.unsafe(nil)); end

  def self.get(path, opts=T.unsafe(nil), &block); end

  def self.handler_name(); end

  def self.handler_name=(val); end

  def self.handler_name?(); end

  def self.head(path, opts=T.unsafe(nil), &bk); end

  def self.helpers(*extensions, &block); end

  def self.inline_templates=(file=T.unsafe(nil)); end

  def self.layout(name=T.unsafe(nil), &block); end

  def self.link(path, opts=T.unsafe(nil), &bk); end

  def self.lock(); end

  def self.lock=(val); end

  def self.lock?(); end

  def self.logging(); end

  def self.logging=(val); end

  def self.logging?(); end

  def self.method_override(); end

  def self.method_override=(val); end

  def self.method_override?(); end

  def self.methodoverride=(val); end

  def self.methodoverride?(); end

  def self.middleware(); end

  def self.mime_type(type, value=T.unsafe(nil)); end

  def self.mime_types(type); end

  def self.mustermann_opts(); end

  def self.mustermann_opts=(val); end

  def self.mustermann_opts?(); end

  def self.new(*args, &bk); end

  def self.new!(*_); end

  def self.not_found(&block); end

  def self.options(path, opts=T.unsafe(nil), &bk); end

  def self.patch(path, opts=T.unsafe(nil), &bk); end

  def self.port(); end

  def self.port=(val); end

  def self.port?(); end

  def self.post(path, opts=T.unsafe(nil), &bk); end

  def self.prefixed_redirects(); end

  def self.prefixed_redirects=(val); end

  def self.prefixed_redirects?(); end

  def self.production?(); end

  def self.protection(); end

  def self.protection=(val); end

  def self.protection?(); end

  def self.prototype(); end

  def self.public=(value); end

  def self.public_dir(); end

  def self.public_dir=(value); end

  def self.public_folder(); end

  def self.public_folder=(val); end

  def self.public_folder?(); end

  def self.put(path, opts=T.unsafe(nil), &bk); end

  def self.quiet(); end

  def self.quiet=(val); end

  def self.quiet?(); end

  def self.quit!(); end

  def self.raise_errors(); end

  def self.raise_errors=(val); end

  def self.raise_errors?(); end

  def self.register(*extensions, &block); end

  def self.reload_templates(); end

  def self.reload_templates=(val); end

  def self.reload_templates?(); end

  def self.reset!(); end

  def self.root(); end

  def self.root=(val); end

  def self.root?(); end

  def self.routes(); end

  def self.run(); end

  def self.run!(options=T.unsafe(nil), &block); end

  def self.run=(val); end

  def self.run?(); end

  def self.running?(); end

  def self.running_server(); end

  def self.running_server=(val); end

  def self.running_server?(); end

  def self.server(); end

  def self.server=(val); end

  def self.server?(); end

  def self.session_secret(); end

  def self.session_secret=(val); end

  def self.session_secret?(); end

  def self.session_store(); end

  def self.session_store=(val); end

  def self.session_store?(); end

  def self.sessions(); end

  def self.sessions=(val); end

  def self.sessions?(); end

  def self.set(option, value=T.unsafe(nil), ignore_setter=T.unsafe(nil), &block); end

  def self.settings(); end

  def self.show_exceptions(); end

  def self.show_exceptions=(val); end

  def self.show_exceptions?(); end

  def self.start!(options=T.unsafe(nil), &block); end

  def self.static(); end

  def self.static=(val); end

  def self.static?(); end

  def self.static_cache_control(); end

  def self.static_cache_control=(val); end

  def self.static_cache_control?(); end

  def self.stop!(); end

  def self.strict_paths(); end

  def self.strict_paths=(val); end

  def self.strict_paths?(); end

  def self.template(name, &block); end

  def self.templates(); end

  def self.test?(); end

  def self.threaded(); end

  def self.threaded=(val); end

  def self.threaded?(); end

  def self.traps(); end

  def self.traps=(val); end

  def self.traps?(); end

  def self.unlink(path, opts=T.unsafe(nil), &bk); end

  def self.use(middleware, *args, &block); end

  def self.use_code(); end

  def self.use_code=(val); end

  def self.use_code?(); end

  def self.views(); end

  def self.views=(val); end

  def self.views?(); end

  def self.x_cascade(); end

  def self.x_cascade=(val); end

  def self.x_cascade?(); end
end

class Sinatra::CommonLogger
end

class Sinatra::CommonLogger
end

module Sinatra::Delegator
end

module Sinatra::Delegator
  def self.delegate(*methods); end

  def self.target(); end

  def self.target=(target); end
end

class Sinatra::ExtendedRack
  def call(env); end
end

class Sinatra::ExtendedRack
end

module Sinatra::Helpers
  def attachment(filename=T.unsafe(nil), disposition=T.unsafe(nil)); end

  def back(); end

  def bad_request?(); end

  def body(value=T.unsafe(nil), &block); end

  def cache_control(*values); end

  def client_error?(); end

  def content_type(type=T.unsafe(nil), params=T.unsafe(nil)); end

  def error(code, body=T.unsafe(nil)); end

  def etag(value, options=T.unsafe(nil)); end

  def expires(amount, *values); end

  def headers(hash=T.unsafe(nil)); end

  def informational?(); end

  def last_modified(time); end

  def logger(); end

  def mime_type(type); end

  def not_found(body=T.unsafe(nil)); end

  def not_found?(); end

  def redirect(uri, *args); end

  def redirect?(); end

  def send_file(path, opts=T.unsafe(nil)); end

  def server_error?(); end

  def session(); end

  def status(value=T.unsafe(nil)); end

  def stream(keep_open=T.unsafe(nil)); end

  def success?(); end

  def time_for(value); end

  def to(addr=T.unsafe(nil), absolute=T.unsafe(nil), add_script_name=T.unsafe(nil)); end

  def uri(addr=T.unsafe(nil), absolute=T.unsafe(nil), add_script_name=T.unsafe(nil)); end

  def url(addr=T.unsafe(nil), absolute=T.unsafe(nil), add_script_name=T.unsafe(nil)); end
  ETAG_KINDS = ::T.let(nil, ::T.untyped)
end

module Sinatra::Helpers
end

class Sinatra::IndifferentHash
  def [](key); end

  def []=(key, value); end

  def assoc(key); end

  def default(*args); end

  def default=(value); end

  def delete(key); end

  def dig(key, *other_keys); end

  def fetch(key, *args); end

  def fetch_values(*keys); end

  def has_key?(key); end

  def has_value?(value); end

  def include?(key); end

  def initialize(*args); end

  def key(value); end

  def key?(key); end

  def member?(key); end

  def merge(other_hash, &block); end

  def merge!(other_hash); end

  def rassoc(value); end

  def replace(other_hash); end

  def slice(*keys); end

  def store(key, value); end

  def transform_keys(&block); end

  def transform_values(&block); end

  def update(other_hash); end

  def value?(value); end

  def values_at(*keys); end
end

class Sinatra::IndifferentHash
  def self.[](*args); end
end

class Sinatra::NotFound
  def http_status(); end
end

class Sinatra::NotFound
end

class Sinatra::Request
  def accept(); end

  def accept?(type); end

  def forwarded?(); end

  def idempotent?(); end

  def preferred_type(*types); end

  def safe?(); end

  def secure?(); end
  HEADER_PARAM = ::T.let(nil, ::T.untyped)
  HEADER_VALUE_WITH_PARAMS = ::T.let(nil, ::T.untyped)
end

class Sinatra::Request::AcceptEntry
  def entry(); end

  def initialize(entry); end

  def method_missing(*args, &block); end

  def params(); end

  def params=(params); end

  def priority(); end

  def respond_to?(*args); end

  def to_s(full=T.unsafe(nil)); end

  def to_str(); end
end

class Sinatra::Request::AcceptEntry
end

class Sinatra::Request
end

class Sinatra::Response
  def body=(value); end

  def each(&blk); end

  def finish(); end

  def initialize(*_); end
  DROP_BODY_RESPONSES = ::T.let(nil, ::T.untyped)
end

class Sinatra::Response
end

class Sinatra::ShowExceptions
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Sinatra::ShowExceptions
end

module Sinatra::Templates
  def asciidoc(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def builder(template=T.unsafe(nil), options=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def coffee(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def creole(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def erb(template, options=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def erubis(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def find_template(views, name, engine); end

  def haml(template, options=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def initialize(); end

  def less(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def liquid(template, options=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def markaby(template=T.unsafe(nil), options=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def markdown(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def mediawiki(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def nokogiri(template=T.unsafe(nil), options=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def rabl(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def radius(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def rdoc(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def sass(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def scss(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def slim(template, options=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def stylus(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def textile(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end

  def wlang(template, options=T.unsafe(nil), locals=T.unsafe(nil), &block); end

  def yajl(template, options=T.unsafe(nil), locals=T.unsafe(nil)); end
end

module Sinatra::Templates
end

class Sinatra::Wrapper
  def call(env); end

  def helpers(); end

  def initialize(stack, instance); end

  def settings(); end
end

class Sinatra::Wrapper
end

module Sinatra
  def self.helpers(*extensions, &block); end

  def self.new(base=T.unsafe(nil), &block); end

  def self.register(*extensions, &block); end

  def self.use(*args, &block); end
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

class Socket
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  SO_BPF_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache
  def all_module_aliases(); end

  def all_module_names(); end

  def all_named_modules(); end

  def class_by_name(name); end

  def name_by_class(klass); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def aliases(); end

  def aliases=(_); end

  def const(); end

  def const=(_); end

  def const_name(); end

  def const_name=(_); end

  def found_name(); end

  def found_name=(_); end

  def owner(); end

  def owner=(_); end

  def primary_name(); end

  def primary_name=(_); end
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::ConstantLookupCache
end

class Sorbet::Private::CreateConfig
  include ::Sorbet::Private::StepInterface
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::CreateConfig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::FetchRBIs
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
  SORBET_RBI_LIST = ::T.let(nil, ::T.untyped)
  SORBET_RBI_SORBET_TYPED = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REPO = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REVISION = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FetchRBIs
  def self.fetch_sorbet_typed(); end

  def self.main(); end

  def self.matching_version_directories(root, version); end

  def self.output_file(); end

  def self.paths_for_gem_version(gemspec); end

  def self.paths_for_ruby_version(ruby_version); end

  def self.vendor_rbis_within_paths(vendor_paths); end
end

class Sorbet::Private::FindGemRBIs
  include ::Sorbet::Private::StepInterface
  GEM_DIR = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FindGemRBIs
  def self.main(); end

  def self.output_file(); end

  def self.paths_within_gem_sources(gemspec); end
end

module Sorbet::Private::GemGeneratorTracepoint
  include ::Sorbet::Private::StepInterface
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def defs(); end

  def defs=(_); end

  def id(); end

  def id=(_); end

  def klass(); end

  def klass=(_); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
  def initialize(files:, delegate_classes:); end

  def serialize(output_dir); end
  BAD_METHODS = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
  def self.add_to_context(item); end

  def self.disable_tracepoints(); end

  def self.finish(); end

  def self.install_tracepoints(); end

  def self.on_method_added(mod, method, singleton); end

  def self.on_module_created(mod); end

  def self.on_module_extended(extended, extender); end

  def self.on_module_included(included, includer); end

  def self.pre_cache_module_methods(); end

  def self.register_delegate_class(klass, delegate); end

  def self.start(); end

  def self.trace(); end

  def self.trace_results(); end
end

module Sorbet::Private::GemGeneratorTracepoint
  def self.main(output_dir=T.unsafe(nil)); end

  def self.output_file(); end
end

class Sorbet::Private::GemLoader
  GEM_LOADER = ::T.let(nil, ::T.untyped)
  NO_GEM = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemLoader
  def self.my_require(gem); end

  def self.require_all_gems(); end

  def self.require_gem(gem); end
end

class Sorbet::Private::HiddenMethodFinder
  include ::Sorbet::Private::StepInterface
  def all_modules_and_aliases(); end

  def capture_stderr(); end

  def constant_cache(); end

  def gen_source_rbi(classes, aliases); end

  def looks_like_stub_name(name); end

  def main(); end

  def mk_dir(); end

  def read_constants(); end

  def real_name(mod); end

  def require_everything(); end

  def rm_dir(); end

  def serialize_alias(source_entry, rbi_entry, my_klass, source_symbols, rbi_symbols); end

  def serialize_class(source_entry, rbi_entry, klass, source_symbols, rbi_symbols, source_by_name); end

  def serialize_constants(source, rbi, klass, is_singleton, source_symbols, rbi_symbols); end

  def symbols_id_to_name(entry, prefix); end

  def write_constants(); end

  def write_diff(source, rbi); end
  BLACKLIST = ::T.let(nil, ::T.untyped)
  DIFF_RBI = ::T.let(nil, ::T.untyped)
  ERRORS_RBI = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  HIDDEN_RBI = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  TMP_PATH = ::T.let(nil, ::T.untyped)
  TMP_RBI = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::HiddenMethodFinder
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private::Main
end

module Sorbet::Private::Main
  def self.cyan(msg); end

  def self.emojify(emoji, msg); end

  def self.init(); end

  def self.main(argv); end

  def self.make_step(step); end

  def self.usage(); end

  def self.yellow(msg); end
end

module Sorbet::Private::RealStdlib
end

module Sorbet::Private::RealStdlib
  def self.real_ancestors(mod); end

  def self.real_autoload?(o, klass); end

  def self.real_const_get(obj, const, arg); end

  def self.real_constants(mod); end

  def self.real_eqeq(obj, other); end

  def self.real_hash(o); end

  def self.real_instance_methods(mod, arg); end

  def self.real_is_a?(o, klass); end

  def self.real_name(o); end

  def self.real_object_id(o); end

  def self.real_private_instance_methods(mod, arg); end

  def self.real_singleton_class(obj); end

  def self.real_singleton_methods(mod, arg); end

  def self.real_spaceship(obj, arg); end

  def self.real_superclass(o); end
end

class Sorbet::Private::RequireEverything
end

class Sorbet::Private::RequireEverything
  def self.excluded_rails_files(); end

  def self.load_bundler(); end

  def self.load_rails(); end

  def self.my_require(abs_path, numerator, denominator); end

  def self.patch_kernel(); end

  def self.rails?(); end

  def self.rails_load_paths(); end

  def self.rb_file_paths(); end

  def self.require_all_files(); end

  def self.require_everything(); end
end

class Sorbet::Private::Serialize
  def alias(base, other_name); end

  def ancestor_has_method(method, klass); end

  def blacklisted_method(method); end

  def class_or_module(class_name); end

  def comparable?(value); end

  def constant(const, value); end

  def from_method(method); end

  def initialize(constant_cache); end

  def serialize_method(method, static=T.unsafe(nil), with_sig: T.unsafe(nil)); end

  def serialize_sig(parameters); end

  def to_sig(kind, name); end

  def valid_class_name(name); end

  def valid_method_name(name); end
  BLACKLIST_CONSTANTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::Serialize
  def self.header(typed=T.unsafe(nil), subcommand=T.unsafe(nil)); end
end

module Sorbet::Private::Status
end

module Sorbet::Private::Status
  def self.done(); end

  def self.say(message, print_without_tty: T.unsafe(nil)); end
end

module Sorbet::Private::StepInterface
end

module Sorbet::Private::StepInterface
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::SuggestTyped
  include ::Sorbet::Private::StepInterface
end

class Sorbet::Private::SuggestTyped
  def self.main(); end

  def self.output_file(); end

  def self.suggest_typed(); end
end

class Sorbet::Private::TodoRBI
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::TodoRBI
  def self.main(); end

  def self.output_file(); end
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class StopIteration
  def result(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def +@(); end

  def -@(); end

  def []=(*_); end

  def casecmp?(_); end

  def each_grapheme_cluster(); end

  def encode(*_); end

  def encode!(*_); end

  def grapheme_clusters(); end

  def parse_csv(**options); end

  def reverse!(); end

  def shellescape(); end

  def shellsplit(); end

  def succ!(); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(_); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

class StringIO
  def length(); end

  def truncate(_); end
end

class StringScanner
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def self.must_C_version(); end
end

class Struct
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class SystemCallError
  def errno(); end
end

class SystemExit
  def status(); end

  def success?(); end
end

class Tempfile
  def _close(); end

  def inspect(); end
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

module Tilt
  LOCK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tilt::CSVTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::CSVTemplate
  def self.engine(); end
end

class Tilt::Cache
  def clear(); end

  def fetch(*key); end
end

class Tilt::Cache
end

module Tilt::CompiledTemplates
end

module Tilt::CompiledTemplates
end

class Tilt::Dummy
end

class Tilt::Dummy
end

class Tilt::ERBTemplate
  def precompiled(locals); end

  def precompiled_postamble(locals); end

  def precompiled_preamble(locals); end

  def precompiled_template(locals); end
  SUPPORTS_KVARGS = ::T.let(nil, ::T.untyped)
end

class Tilt::ERBTemplate
  def self.default_output_variable(); end

  def self.default_output_variable=(name); end
end

class Tilt::EtanniTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::EtanniTemplate
end

class Tilt::Mapping
  def [](file); end

  def extensions_for(template_class); end

  def lazy_map(); end

  def new(file, line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def register(template_class, *extensions); end

  def register_lazy(class_name, file, *extensions); end

  def registered?(ext); end

  def template_for(file); end

  def template_map(); end

  def templates_for(file); end
  AUTOLOAD_IS_BROKEN = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
end

class Tilt::Mapping
end

class Tilt::PlainTemplate
end

class Tilt::PlainTemplate
end

class Tilt::RDocTemplate
  def allows_script?(); end

  def markup(); end
end

class Tilt::RDocTemplate
end

class Tilt::SigilTemplate
  def allows_script?(); end
end

class Tilt::SigilTemplate
end

class Tilt::StringTemplate
  def precompiled(locals); end

  def precompiled_template(locals); end
end

class Tilt::StringTemplate
end

Tilt::TOPOBJECT = Tilt::CompiledTemplates

class Tilt::Template
  def basename(suffix=T.unsafe(nil)); end

  def data(); end

  def default_encoding(); end

  def eval_file(); end

  def evaluate(scope, locals, &block); end

  def file(); end

  def initialize(file=T.unsafe(nil), line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def line(); end

  def metadata(); end

  def name(); end

  def options(); end

  def precompiled(local_keys); end

  def precompiled_postamble(local_keys); end

  def precompiled_preamble(local_keys); end

  def precompiled_template(local_keys); end

  def prepare(); end

  def render(scope=T.unsafe(nil), locals=T.unsafe(nil), &block); end
end

class Tilt::Template
  def self.default_mime_type(); end

  def self.default_mime_type=(value); end

  def self.metadata(); end
end

module Tilt
  def self.[](file); end

  def self.current_template(); end

  def self.default_mapping(); end

  def self.lazy_map(); end

  def self.new(file, line=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.prefer(template_class, *extensions); end

  def self.register(template_class, *extensions); end

  def self.register_lazy(class_name, file, *extensions); end

  def self.registered?(ext); end

  def self.template_for(file); end

  def self.templates_for(file); end
end

class TracePoint
  def event(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

class URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::HTTP
  def request_uri(); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.get_encoding(label); end
end

class UnboundMethod
  def clone(); end

  def original_name(); end
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

class UploadIO
  def content_type(); end

  def initialize(filename_or_io, content_type, filename=T.unsafe(nil), opts=T.unsafe(nil)); end

  def io(); end

  def local_path(); end

  def method_missing(*args); end

  def opts(); end

  def original_filename(); end

  def respond_to?(meth, include_all=T.unsafe(nil)); end
end

class UploadIO
  def self.convert!(io, content_type, original_filename, local_path); end
end

module Warning
  def warn(_); end
end

module Warning
  extend ::Warning
end

module Zlib
  ASCII = ::T.let(nil, ::T.untyped)
  BEST_COMPRESSION = ::T.let(nil, ::T.untyped)
  BEST_SPEED = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  DEFAULT_COMPRESSION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRATEGY = ::T.let(nil, ::T.untyped)
  DEF_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  FILTERED = ::T.let(nil, ::T.untyped)
  FINISH = ::T.let(nil, ::T.untyped)
  FIXED = ::T.let(nil, ::T.untyped)
  FULL_FLUSH = ::T.let(nil, ::T.untyped)
  HUFFMAN_ONLY = ::T.let(nil, ::T.untyped)
  MAX_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  MAX_WBITS = ::T.let(nil, ::T.untyped)
  NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  NO_FLUSH = ::T.let(nil, ::T.untyped)
  OS_AMIGA = ::T.let(nil, ::T.untyped)
  OS_ATARI = ::T.let(nil, ::T.untyped)
  OS_CODE = ::T.let(nil, ::T.untyped)
  OS_CPM = ::T.let(nil, ::T.untyped)
  OS_MACOS = ::T.let(nil, ::T.untyped)
  OS_MSDOS = ::T.let(nil, ::T.untyped)
  OS_OS2 = ::T.let(nil, ::T.untyped)
  OS_QDOS = ::T.let(nil, ::T.untyped)
  OS_RISCOS = ::T.let(nil, ::T.untyped)
  OS_TOPS20 = ::T.let(nil, ::T.untyped)
  OS_UNIX = ::T.let(nil, ::T.untyped)
  OS_UNKNOWN = ::T.let(nil, ::T.untyped)
  OS_VMCMS = ::T.let(nil, ::T.untyped)
  OS_VMS = ::T.let(nil, ::T.untyped)
  OS_WIN32 = ::T.let(nil, ::T.untyped)
  OS_ZSYSTEM = ::T.let(nil, ::T.untyped)
  RLE = ::T.let(nil, ::T.untyped)
  SYNC_FLUSH = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  ZLIB_VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::BufError
end

class Zlib::BufError
end

class Zlib::DataError
end

class Zlib::DataError
end

class Zlib::Deflate
  def <<(_); end

  def deflate(*_); end

  def flush(*_); end

  def initialize(*_); end

  def params(_, _1); end

  def set_dictionary(_); end
end

class Zlib::Deflate
  def self.deflate(*_); end
end

class Zlib::Error
end

class Zlib::Error
end

class Zlib::GzipFile
  def close(); end

  def closed?(); end

  def comment(); end

  def crc(); end

  def finish(); end

  def level(); end

  def mtime(); end

  def orig_name(); end

  def os_code(); end

  def sync(); end

  def sync=(sync); end

  def to_io(); end
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::Error
  def input(); end
end

class Zlib::GzipFile::Error
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile
  def self.wrap(*_); end
end

class Zlib::GzipReader
  include ::Enumerable
  def bytes(); end

  def each(*_, &blk); end

  def each_byte(); end

  def each_char(); end

  def each_line(*_); end

  def eof(); end

  def eof?(); end

  def external_encoding(); end

  def getbyte(); end

  def getc(); end

  def initialize(*_); end

  def lineno(); end

  def lineno=(lineno); end

  def lines(*_); end

  def pos(); end

  def read(*_); end

  def readbyte(); end

  def readchar(); end

  def readpartial(*_); end

  def rewind(); end

  def tell(); end

  def ungetbyte(_); end

  def ungetc(_); end

  def unused(); end
end

class Zlib::GzipReader
end

class Zlib::GzipWriter
  def <<(_); end

  def comment=(comment); end

  def flush(*_); end

  def initialize(*_); end

  def mtime=(mtime); end

  def orig_name=(orig_name); end

  def pos(); end

  def tell(); end

  def write(*_); end
end

class Zlib::GzipWriter
end

class Zlib::Inflate
  def <<(_); end

  def add_dictionary(_); end

  def inflate(_); end

  def initialize(*_); end

  def set_dictionary(_); end

  def sync(_); end

  def sync_point?(); end
end

class Zlib::Inflate
  def self.inflate(_); end
end

class Zlib::MemError
end

class Zlib::MemError
end

class Zlib::NeedDict
end

class Zlib::NeedDict
end

class Zlib::StreamEnd
end

class Zlib::StreamEnd
end

class Zlib::StreamError
end

class Zlib::StreamError
end

class Zlib::VersionError
end

class Zlib::VersionError
end

class Zlib::ZStream
  def adler(); end

  def avail_in(); end

  def avail_out(); end

  def avail_out=(avail_out); end

  def close(); end

  def closed?(); end

  def data_type(); end

  def end(); end

  def ended?(); end

  def finish(); end

  def finished?(); end

  def flush_next_in(); end

  def flush_next_out(); end

  def reset(); end

  def stream_end?(); end

  def total_in(); end

  def total_out(); end
end

class Zlib::ZStream
end

module Zlib
  def self.adler32(*_); end

  def self.adler32_combine(_, _1, _2); end

  def self.crc32(*_); end

  def self.crc32_combine(_, _1, _2); end

  def self.crc_table(); end

  def self.deflate(*_); end

  def self.gunzip(_); end

  def self.gzip(*_); end

  def self.inflate(_); end

  def self.zlib_version(); end
end
